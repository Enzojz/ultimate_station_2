local func = require "ust/func"
local coor = require "ust/coor"
local arc = require "ust/coorarc"
local pipe = require "ust/pipe"
local general = require "ust/general"
local ust = require "ust"
local dump = require "luadump"

local unpack = table.unpack
local abs = math.abs

local function classifyModules(params)
    local result = {}
    for slotId, m in pairs(params) do
        local type = slotId % 100
        local id = (slotId - type) / 100 % 1000
        m.typeId = type
        if not result[id] then result[id] = {info = {}} end
        if (type < 50) then
            result[id].type = type
            result[id].slotId = slotId
            result[id].data = math.floor(slotId / 1000000)
        else
            local data = math.floor(slotId / 1000000)
            result[id].info[type] = data
        end
    end
    return result
end

local constructionTemplates =
    {
        {
            constructionType = "RAIL_STATION",
            type = "DYNAMIC",
            availability = {
                yearFrom = 0,
                yearTo = 0
            },
            description = {
                name = _("MENU_NAME"),
                description = _("MENU_NAME")
            },
            data = {
                params = {}
            },
        }
    }

local arcPacker = function(pt, vec, length, radius)
    local nVec = vec:withZ(0):normalized()
    local tVec = coor.xyz(-nVec.y, nVec.x, 0)
    local o = pt + tVec * radius
    local ar = arc.byOR(o, abs(radius))
    local inf = ar:rad(pt)
    local sup = inf + length / radius
    ar = ar:withLimits({
        sup = sup,
        inf = inf
    })
    return function(...)
        local result = func.map({...}, function(dr)
            return arc.byOR(o, abs(radius - dr), {
                sup = sup,
                inf = inf
            })
        end)
        return ar, table.unpack(result)
    end
end

local createTemplateFn = function(_)
    local result = {
            
            [401] = "station/rail/ust/ust_track.module",
            [10000451] = "station/rail/ust/ust_data.module",
            [11000452] = "station/rail/ust/ust_data.module",
            [453] = "station/rail/ust/ust_data.module",
            [500000454] = "station/rail/ust/ust_data.module",
            [20000455] = "station/rail/ust/ust_data.module",
            
            [101] = "station/rail/ust/ust_track.module",
            [10000151] = "station/rail/ust/ust_data.module",
            [10000152] = "station/rail/ust/ust_data.module",
            [153] = "station/rail/ust/ust_data.module",
            [500000154] = "station/rail/ust/ust_data.module",
            [20000155] = "station/rail/ust/ust_data.module",
            
            [201] = "station/rail/ust/ust_track.module",
            [10000251] = "station/rail/ust/ust_data.module",
            [20000252] = "station/rail/ust/ust_data.module",
            [253] = "station/rail/ust/ust_data.module",
            [500000254] = "station/rail/ust/ust_data.module",
            [20000255] = "station/rail/ust/ust_data.module",
            -- [5000156] = "station/rail/ust/ust_data.module",
            [301] = "station/rail/ust/ust_track.module",
            [10000351] = "station/rail/ust/ust_data.module",
            [30000352] = "station/rail/ust/ust_data.module",
            [353] = "station/rail/ust/ust_data.module",
            [500000354] = "station/rail/ust/ust_data.module",
            [20000355] = "station/rail/ust/ust_data.module",
            -- [5000156] = "station/rail/ust/ust_data.module",

            [501] = "station/rail/ust/ust_track.module",
            [20000551] = "station/rail/ust/ust_data.module",
            [10000552] = "station/rail/ust/ust_data.module",
            [553] = "station/rail/ust/ust_data.module",
            [20000555] = "station/rail/ust/ust_data.module",
            
            [601] = "station/rail/ust/ust_track.module",
            [20000651] = "station/rail/ust/ust_data.module",
            [20000652] = "station/rail/ust/ust_data.module",
            [653] = "station/rail/ust/ust_data.module",
            [20000655] = "station/rail/ust/ust_data.module",
            [701] = "station/rail/ust/ust_track.module",
            [20000751] = "station/rail/ust/ust_data.module",
            [30000752] = "station/rail/ust/ust_data.module",
            [753] = "station/rail/ust/ust_data.module",
            [20000755] = "station/rail/ust/ust_data.module",
            [801] = "station/rail/ust/ust_track.module",
            [20000851] = "station/rail/ust/ust_data.module",
            [11000852] = "station/rail/ust/ust_data.module",
            [853] = "station/rail/ust/ust_data.module",
            [20000855] = "station/rail/ust/ust_data.module",
    -- [202] = "station/rail/ust/ust_platform.module",
    -- [11000251] = "station/rail/ust/ust_data.module",
    -- [11000252] = "station/rail/ust/ust_data.module",
    -- [253] = "station/rail/ust/ust_data.module",
    -- -- [154] = "station/rail/ust/ust_data.module",
    -- [20000255] = "station/rail/ust/ust_data.module",
    -- [5000256] = "station/rail/ust/ust_data.module",
    -- [201] = "station/rail/ust/ust_track.module",
    -- [10251] = "station/rail/ust/ust_data.module",
    -- [20252] = "station/rail/ust/ust_data.module",
    -- [253] = "station/rail/ust/ust_data.module",
    -- -- [254] = "station/rail/ust/ust_data.module",
    -- [20255] = "station/rail/ust/ust_data.module",
    }
    
    return result
end

local preProcessFn = function(modules, change)
    local classedModules = classifyModules(modules)
    
    local maxId = 0
    for slotId, module in pairs(modules) do
        module.info = ust.slotInfo(slotId, classedModules)
        if maxId < module.info.id then
            maxId = module.info.id
        end
    end
    
    if change.added then
        local info = ust.slotInfo(change.slotId, classedModules)
        local data = math.floor(change.slotId / 1000000)
        if (data < 5) then
            local dpos = ({
                coor.xyz(-1, 0, 0),
                coor.xyz(1, 0, 0),
                coor.xyz(0, -1, 0),
                coor.xyz(0, 1, 0)
            })[data]
            local newInfo = {
                id = maxId + 1,
                type = change.module.metadata.typeId,
                pos = info.pos + dpos,
                length = 20,
                width = 5
            }
            local slotId, dataIds = ust.slotIds(newInfo)
            modules[slotId] = change.module
            
            for key, slotId in pairs(dataIds) do
                modules[slotId] = {
                    metadata = {isData = true},
                    name = "station/rail/ust/ust_data.module",
                    updateScript = {
                        fileName = "",
                        params = {}
                    },
                    variant = 0
                }
            end
        end
    end
    return modules
end

local upgradeFn = function(_) end



local updateFn = function(params)
    local result = {
        entryConnectors = {},
        colliders = {},
        terrainAlignmentLists = {},
        groundFaces = {},
        terminalGroups = {},
        stations = {},
        dependentSlots = {},
        edgeLists = {},
        slotConfig = {},
        occupied = {{}, {}, {}, {}},
        cost = 0,
        models = pipe.new * {},
        slots = {},
    }
    
    
    params.classedModules = classifyModules(params.modules)
    for slotId, module in pairs(params.modules) do
        module.info = ust.slotInfo(slotId, params.classedModules)
    end
    
    
    local grid = {}
    for slotId, module in pairs(params.modules) do
        if not module.metadata.isData then
            local info = module.info
            if not grid[info.pos.z] then grid[info.pos.z] = {} end
            if not grid[info.pos.z][info.pos.x] then grid[info.pos.z][info.pos.x] = {} end
            grid[info.pos.z][info.pos.x][info.pos.y] = slotId
        end
    end
    for z, zv in pairs(grid) do
        local xPos = func.sort(func.filter(func.keys(zv), function(k) return k >= 0 end))
        local xNeg = func.rev(func.sort(func.filter(func.keys(zv), function(k) return k < 0 end)))
        local xState = false
        for _, x in ipairs(xPos) do
            
            if (not xState) then
                xState = {
                    pos = 0,
                    radius = 10e8,
                    refList = {},
                    yStates = {}
                }
            end
            
            xState.refList[x] = xState.pos
            xState.yStates[x] = {}
            
            local yPos = func.sort(func.filter(func.keys(grid[z][x]), function(k) return k >= 0 end))
            local yNeg = func.rev(func.sort(func.filter(func.keys(grid[z][x]), function(k) return k < 0 end)))
            
            local yState = false
            for _, y in ipairs(func.sort(yPos)) do
                local slotId = grid[z][x][y]
                local m = params.modules[slotId]
                
                if (not yState) then
                    local width = m.info.width or m.metadata.width or 5
                    yState = {
                        pos = coor.xyz(xState.pos + width * 0.5, 0, 0),
                        vec = coor.xyz(0, 1, 0),
                        width = width,
                        radius = m.info.radius or 10e8,
                        length = m.info.length
                    }
                    yState.ref = func.with(yState, {})
                end

                if m.info.radius then
                    yState.radius = m.info.radius
                else
                    for i = x - 1, 0, -1 do
                        if xState.yStates[i] and xState.yStates[i][y] then
                            yState.radius = xState.yStates[i][y].radius + (xState.pos - xState.refList[i])
                            break
                        end
                    end
                end
                                
                xState.yStates[x][y] = yState
                
                local ar, arL, arR =
                    arcPacker(yState.pos, yState.vec, yState.length, yState.radius)(-yState.width * 0.5, yState.width * 0.5)
                
                local refArc = {
                    left = arL,
                    right = arR,
                    center = ar
                }
                
                params.modules[slotId].info.arcs = refArc
                
                params.modules[slotId].info.pts = {
                    refArc.center:pt(refArc.center.inf),
                    refArc.center:tangent(refArc.center.inf),
                    refArc.center:pt(refArc.center.sup),
                    refArc.center:tangent(refArc.center.sup)
                }
                
                yState.vec = refArc.center:tangent(refArc.center.sup)
                yState.pos = refArc.center:pt(refArc.center.sup)
            end
            
            yState = yState and yState.ref or false
            
            for _, y in ipairs(func.sort(yNeg)) do
                local slotId = grid[z][x][y]
                local m = params.modules[slotId]
                
                if (not yState) then
                    local width = m.info.width or m.metadata.width or 5
                    yState = {
                        pos = coor.xyz(xState.pos + width * 0.5, 0, 0),
                        vec = coor.xyz(0, -1, 0),
                        width = width,
                        radius = m.info.radius or 10e8,
                        length = m.info.length
                    }
                else
                    yState.vec = -yState.vec
                end
                
                if m.info.radius then
                    yState.radius = m.info.radius
                else
                    for i = x - 1, 0, -1 do
                        if xState.yStates[i] and xState.yStates[i][y] then
                            yState.radius = xState.yStates[i][y].radius + (xState.pos - xState.refList[i])
                            break
                        end
                    end
                end
                                
                xState.yStates[x][y] = yState
                
                xState.yStates[x][y] = yState
                
                local ar, arL, arR =
                    arcPacker(yState.pos, yState.vec, yState.length, -yState.radius)(-yState.width * 0.5, yState.width * 0.5)
                
                local refArc = {
                    left = arL,
                    right = arR,
                    center = ar
                }
                
                params.modules[slotId].info.arcs = refArc
                
                params.modules[slotId].info.pts = {
                    refArc.center:pt(refArc.center.inf),
                    refArc.center:tangent(refArc.center.inf),
                    refArc.center:pt(refArc.center.sup),
                    refArc.center:tangent(refArc.center.sup)
                }
                
                yState.vec = refArc.center:tangent(refArc.center.sup)
                yState.pos = refArc.center:pt(refArc.center.sup)
            end
            
            if yState and yState.width then
                xState.pos = xState.pos + yState.width
            end
        end
    end
    
    for slotId, module in pairs(params.modules) do
        table.insert(result.slots, {
            id = slotId,
            transf = module.transf or coor.I(),
            type = ust.typeList[module.typeId] or "ust_data",
            spacing = {2.5, 2.5, 2.5, 2.5}
        })
        
        if not module.metadata.isData then
            table.insert(result.slots, {
                id = ust.mixData(slotId, 1, true),
                transf = coor.trans(coor.xyz(-5, 0, 0) .. (module.transf or coor.I())),
                type = "ust_platform",
                spacing = {2.5, 2.5, 2.5, 2.5}
            })
            table.insert(result.slots, {
                id = ust.mixData(slotId, 2, true),
                transf = coor.trans(coor.xyz(5, 0, 0) .. (module.transf or coor.I())),
                type = "ust_platform",
                spacing = {2.5, 2.5, 2.5, 2.5}
            })
            table.insert(result.slots, {
                id = ust.mixData(slotId, 3, true),
                transf = coor.trans(coor.xyz(0, -20, 0) .. (module.transf or coor.I())),
                type = "ust_platform",
                spacing = {2.5, 2.5, 2.5, 2.5}
            })
            table.insert(result.slots, {
                id = ust.mixData(slotId, 4, true),
                transf = coor.trans(coor.xyz(0, 20, 0) .. (module.transf or coor.I())),
                type = "ust_platform",
                spacing = {2.5, 2.5, 2.5, 2.5}
            })
        end
    end
    
    
    for z, gridx in pairs(grid) do
        for x, gridy in pairs(gridx) do
            local ys = func.keys(gridy)
            local min = func.min(ys)
            local max = func.max(ys)
        
        end
    end
    
    result.terminateConstructionHook = function()
        end
    return result
end

function data()
    
    return {
        type = "RAIL_STATION",
        description = {
            name = _("MENU_NAME"),
            description = _("MENU_NAME")
        },
        availability = {
            yearFrom = 0,
            yearTo = 0
        },
        order = 1000,
        constructionTemplates = constructionTemplates,
        createTemplateFn = createTemplateFn,
        params = {
        },
        upgradeFn = upgradeFn,
        updateFn = updateFn,
        preProcessFn = preProcessFn
    }
end
