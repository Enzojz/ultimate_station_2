local func = require "ust/func"
local coor = require "ust/coor"
local arc = require "ust/coorarc"
local line = require "ust/coorline"
local quat = require "ust/quaternion"
local pipe = require "ust/pipe"
local general = require "ust/general"
local ust = require "ust"
local dump = require "luadump"
local livetext = require "ust/livetext"

local unpack = table.unpack
local insert = table.insert
local abs = math.abs
local floor = math.floor

local rList = {15, 12, 10, 8, 7.5, 6, 5, 4, 3.5, 3, 2.5, 2, 1.75, 1.5, 1.25, 1, 0.9, 0.85, 0.8, 0.75, 0.7, 0.666, 0.633, 0.6, 0.566, 0.533, 0.5, 0.475, 0.45, 0.425, 0.4, 0.375, 0.35, 0.325, 0.3, 0.28, 0.26, 0.24, 0.22, 0.2, 0.18, 0.16, 0.14, 0.12, 0.1, 0.09, 0.08, 0.07, 0.06, 0.05}

rList = pipe.new * rList * pipe.map(pipe.neg()) * pipe.rev() / ust.infi + rList
local hPlatformList = {200, 280, 380, 550, 680, 760, 915, 960, 1100, 1219, 1250, 1380}
local trackLengths = {40, 60, 80, 100, 140, 160, 200, 240, 320, 400, 480, 500, 550, 850, 1050}
local trackNumberList = {1, 2, 3, 4, 5, 6, 7, 8, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20}

local function classifyModules(modules)
    local result = {}
    for slotId, m in pairs(modules) do
        if (m.metadata and m.metadata.preClassify) then
            game.res.script[m.metadata.scriptName][m.metadata.preClassify](modules, result, slotId)
        end
    end
    for slotId, m in pairs(modules) do
        if (m.metadata and m.metadata.classify) then
            game.res.script[m.metadata.scriptName][m.metadata.classify](modules, result, slotId)
        end
    end
    for slotId, m in pairs(modules) do
        if (m.metadata and m.metadata.postClassify) then
            game.res.script[m.metadata.scriptName][m.metadata.postClassify](modules, result, slotId)
        end
    end
    return result
end

local constructionTemplates =
    {
        {
            constructionType = "RAIL_STATION",
            type = "DYNAMIC",
            availability = {
                yearFrom = 0,
                yearTo = 0
            },
            description = {
                name = _("MENU_NAME"),
                description = _("MENU_DESC")
            },
            data = {
                params = {}
            },
        }
    }

local createTemplateFn = function(params)
    local baseLength = trackLengths[params.lPlatform + 1]
    local nbTracks = trackNumberList[params.trackNb + 1]
    local radius = rList[params.radius]
    
    local nSeg = baseLength / 20
    
    local posList = func.rev(params.platformLeft and ust.posGen(nbTracks, false) or ust.posGen(nbTracks))
    
    local xOffset = posList[1] and 0 or -1
    -- local trackType = ("%s%s.module"):format(params.capturedParams.moduleList[params.trackType + 1], params.catenary == 1 and "_catenary" or "")
    
    local result = {}
    
    local yMax = nSeg % 2 == 0 and (nSeg / 2 - 1) or (nSeg - 1) / 2
    local yMin = nSeg % 2 == 0 and (-nSeg / 2) or (1 - nSeg) / 2

    for i, isTrack in ipairs(posList) do
        local x = i - 1 + xOffset
        if isTrack then
            for y = yMin, yMax do
                local info = {
                    id = (x >= 0  and x or ((#posList + xOffset - 1) - x)) * nSeg + (y >= 0 and y or (yMax - y)) + 1,
                    type = 1,
                    pos = coor.xyz(x, y, 0),
                    length = 20,
                    width = 5
                }
                local slotId, slotIds = ust.slotIds(info)
                result[slotId] = "station/rail/ust/tracks/high_speed.module"
                for m, slotIds in pairs(slotIds) do
                    for _, slotId in ipairs(slotIds) do
                        result[slotId] = string.format("station/rail/ust/%s.module", m)
                    end
                end
            end
        else
            for y = yMin, yMax do
                local info = {
                    id = (x >= 0  and x or ((#posList + xOffset - 1) - x)) * nSeg + (y >= 0 and y or (yMax - y)) + 1,
                    type = 2,
                    pos = coor.xyz(x, y, 0),
                    length = 20,
                    width = 5,
                    ref = { left = posList[i - 1] == true, right = posList[i + 1] == true  }
                }
                local slotId, slotIds = ust.slotIds(info)
                result[slotId] = "station/rail/ust/era_c/platform.module"
                for m, slotIds in pairs(slotIds) do
                    for _, slotId in ipairs(slotIds) do
                        result[slotId] = string.format("station/rail/ust/%s.module", m)
                    end
                end
            end
        end
    end
    return result
end

local preProcessFn = function(modules, change)
    local classedModules = classifyModules(modules)

    local type, id, data = ust.slotInfo(change.slotId)

    local info = {
        type = type, 
        id = id, 
        data = data
    }
    
    if change.added then
        if change.module.metadata.preProcessAdd then
            game.res.script[change.module.metadata.scriptName][change.module.metadata.preProcessAdd](modules, change, classedModules, info)
        else
            if data == -1 then
                modules[change.slotId] = nil
                modules[ust.base(id, change.module.metadata.typeId)] = change.module
            else
                modules[change.slotId] = nil
                modules[ust.mixData(ust.base(id, change.module.metadata.typeId), data)] = change.module
            end
        end

        for k, module in pairs(modules) do
            if (module.metadata and module.metadata.preProcessPostAdd) then
                game.res.script[module.metadata.scriptName][module.metadata.preProcessPostAdd](modules, change, k, classedModules, info)
            end
        end
    else
        if change.module.metadata.preProcessRemove then
            game.res.script[change.module.metadata.scriptName][change.module.metadata.preProcessRemove](modules, change, classedModules, info)
        else
            modules[change.slotId] = nil
        end
    end
        
    return modules
end

local function searchTerminalGroups(params, current, ...)
    if current == nil then
        return
    end
    
    local m = params.modules[current]
    if m.metadata.isTrack and not m.info.trackGroup then
        while m.info.octa[1] and params.modules[m.info.octa[1]].metadata.isTrack do
            m = params.modules[m.info.octa[1]]
        end
        
        local groupLeft = {{}}
        local groupRight = {{}}
        
        repeat
            if not m.info.trackGroup then
                m.info.trackGroup = {}
            end
            if m.info.octa[7] and params.modules[m.info.octa[7]].metadata.isPlatform then
                table.insert(groupLeft[#groupLeft], m.info.slotId)
            elseif (#groupLeft[#groupLeft] > 0) then
                table.insert(groupLeft, {})
            end
            if m.info.octa[3] and params.modules[m.info.octa[3]].metadata.isPlatform then
                table.insert(groupRight[#groupRight], m.info.slotId)
            elseif (#groupRight[#groupRight] > 0) then
                table.insert(groupRight, {})
            end
            m = params.modules[m.info.octa[5]]
        until not m or not m.metadata.isTrack
        
        for _, groupLeft in ipairs(groupLeft) do
            if (#groupLeft > 0) then
                table.insert(params.trackGroup, groupLeft)
                for _, slotId in ipairs(groupLeft) do
                    params.modules[slotId].info.trackGroup.left = #params.trackGroup
                end
            end
        end
        
        for _, groupRight in ipairs(groupRight) do
            if (#groupRight > 0) then
                table.insert(params.trackGroup, groupRight)
                for _, slotId in ipairs(groupRight) do
                    params.modules[slotId].info.trackGroup.right = #params.trackGroup
                end
            end
        end
    end
    searchTerminalGroups(params, ...)
end

local upgradeFn = function(_) end

local updateFn = function(params, closureParams)
    
    local result = {
        entryConnectors = {},
        colliders = {},
        terrainAlignmentLists = {
            {type = "EQUAL", faces = {}},
            {type = "LESS", faces = {}},
            {type = "GREATER", faces = {}}
        },
        groundFaces = {},
        terminalGroups = {},
        stations = {},
        dependentSlots = {},
        edgeLists = {},
        slotConfig = {},
        occupied = {{}, {}, {}, {}},
        cost = 0,
        models = pipe.new * {},
        slots = {},
        labelText = {},
        connectors = {
            overpass = {},
            underpass = {},
            misc = {}
        },
        connections = {
            underpass = {}
        },
        invokeLater = {}
    }

    params.debug = true --Crash bug when live text is introduced
    
    params.classedModules = classifyModules(params.modules)
    local grid, lowestHeight = ust.gridization(params.modules, params.classedModules)
    -- dump()(params.classedModules)
    -- dump()(params.modules)
    
    params.grid = grid
    params.lowestHeight = lowestHeight
    params.platformHeight = params.lowestHeight + hPlatformList[params.hPlatform + 1] * 0.001

    params.slotGrid = {}

    params.trackGroup = {}
    params.platformGroup = {}
    params.edgeIndex = {}
    params.extra = {}

    searchTerminalGroups(params, unpack(func.map(func.sort(func.keys(params.classedModules)), function(id) return params.classedModules[id].slotId end)))
    params.edgeGroup = {}

    for slotId, module in pairs(params.modules) do
        if module.metadata.slotSetup then
            game.res.script[module.metadata.scriptName][module.metadata.slotSetup](params, result, slotId)
        end
    end
    
    for k, s in pairs(game.res.script) do
        if s.addSlot and k:match("construction/station/rail/ust/") then
            s.addSlot(params, result)
        end
    end
    
    result.terminateConstructionHook = function()
        for i, track in ipairs(params.trackGroup) do
            local platform = params.platformGroup[i]
            if platform then
                local edge = func.map(track, function(t) return params.edgeGroup[t] end)
                if (platform.right) then
                    insert(
                        result.terminalGroups,
                        {
                            terminals = func.map(platform.models, function(p) return {p, 0} end),
                            vehicleNodeOverride = #edge % 2 == 0 and edge[#edge / 2][11] or edge[(#edge + 1) / 2][8]
                        }
                )
                end
                
                if (platform.left) then
                    insert(
                        result.terminalGroups,
                        {
                            terminals = func.map(platform.models, function(p) return {p, 0} end),
                            vehicleNodeOverride = #edge % 2 == 0 and edge[#edge / 2 + 1][1] or edge[(#edge + 1) / 2][6]
                        }
                )
                end
            end
        end
        
        for _, z in pairs(params.slotGrid) do
            for _, x in pairs(z) do
                for _, y in pairs(x) do
                    for _, s in pairs(y) do
                        insert(result.slots, s)
                    end
                end
            end
        end
        
        for _, fn in ipairs(result.invokeLater) do
            fn()
        end
    end
    return result
end

function data()
    return {
        type = "RAIL_STATION",
        description = {
            name = _("MENU_NAME"),
            description = _("MENU_NAME")
        },
        availability = {
            yearFrom = 0,
            yearTo = 0
        },
        order = 1000,
        constructionTemplates = constructionTemplates,
        createTemplateFn = createTemplateFn,
        params = {
            {
                key = "trackNb",
                name = _("MENU_TRACK_NR"),
                values = func.map(trackNumberList, tostring),
                uiType = "SLIDER",
                defaultIndex = 0
            },
            {
                key = "trackType",
                name = _("MENU_TRACK_TYPE"),
                uiType = "COMBOBOX",
                values = {_("Standard"), _("High-Speed")},
                defaultIndex = 0
            },
            {
                key = "catenary",
                name = _("MENU_TRACK_CAT"),
                values = {_("YES"), _("NO")},
                defaultIndex = 0
            },
            {
                key = "radius",
                name = _("MENU_RADIUS"),
                values = rList * pipe.map(function(r) return r > 15 and "∞" or tostring(math.floor(r * 1000)) end),
                uiType = "SLIDER",
                defaultIndex = (#rList - 1) / 2
            },
            {
                key = "lPlatform",
                name = _("MENU_PLATFORM_LENGTH"),
                values = func.map(trackLengths, tostring),
                uiType = "SLIDER",
                defaultIndex = 0
            },
            {
                key = "hPlatform",
                name = _("MENU_PLATFORM_HEIGHT"),
                values = func.map(hPlatformList, tostring),
                uiType = "SLIDER",
                defaultIndex = 3
            },
            {
                key = "platformWidth",
                name = _("MENU_PLATFORM_WIDTH"),
                values = {"5", "10", "15", "20"},
                defaultIndex = 1
            },
            {
                key = "platformLeft",
                name = _("MENU_PLATFORM_LEFT"),
                values = {_("YES"), _("NO")},
                defaultIndex = 0
            },
            {
                key = "platformRight",
                name = _("MENU_PLATFORM_RIGHT"),
                values = {_("YES"), _("NO"), _("AUTO")},
                defaultIndex = 2
            },
        },
        upgradeFn = upgradeFn,
        updateFn = updateFn,
        preProcessFn = preProcessFn
    }
end
