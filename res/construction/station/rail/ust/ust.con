local func = require "ust/func"
local coor = require "ust/coor"
local arc = require "ust/coorarc"
local line = require "ust/coorline"
local quat = require "ust/quaternion"
local pipe = require "ust/pipe"
local general = require "ust/general"
local ust = require "ust"
local dump = require "luadump"
local livetext = require "ust/livetext"

local unpack = table.unpack
local insert = table.insert
local abs = math.abs
local pow = math.pow
local floor = math.floor
local pi = math.pi

local rList = {15, 12, 10, 8, 7.5, 6, 5, 4, 3.5, 3, 2.5, 2, 1.75, 1.5, 1.25, 1, 0.9, 0.85, 0.8, 0.75, 0.7, 0.666, 0.633, 0.6, 0.566, 0.533, 0.5, 0.475, 0.45, 0.425, 0.4, 0.375, 0.35, 0.325, 0.3, 0.28, 0.26, 0.24, 0.22, 0.2, 0.18, 0.16, 0.14, 0.12, 0.1, 0.09, 0.08, 0.07, 0.06, 0.05}

rList = pipe.new * rList * pipe.map(pipe.neg()) * pipe.rev() / ust.infi + rList
local hPlatformList = {200, 280, 380, 550, 680, 760, 915, 960, 1100, 1219, 1250, 1380}
local trackLengths = {40, 60, 80, 100, 140, 160, 200, 240, 320, 400, 480, 500, 550, 850, 1050}
local trackNumberList = {1, 2, 3, 4, 5, 6, 7, 8, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20}

local function classifyModules(params)
    local result = {}
    for slotId, m in pairs(params) do
        local slotIdAbs = abs(slotId)
        local type = slotIdAbs % 100
        local id = (slotIdAbs - type) / 100 % 10000
        m.typeId = type
        if not result[id] then result[id] = {info = {}, slot = {}, metadata = {}} end
        if (type < 50) then
            result[id].type = type
            result[id].slotId = slotId
            result[id].data = slotId > 0 and floor(slotIdAbs / 1000000) or -floor(slotIdAbs / 1000000)
        else
            local data = slotId > 0 and floor(slotIdAbs / 1000000) or -floor(slotIdAbs / 1000000)
            result[id].info[type] = data
            result[id].slot[type] = slotId
            result[id].metadata[type] = m.metadata
        end
    end
    return result
end

local constructionTemplates =
    {
        {
            constructionType = "RAIL_STATION",
            type = "DYNAMIC",
            availability = {
                yearFrom = 0,
                yearTo = 0
            },
            description = {
                name = _("MENU_NAME"),
                description = _("MENU_NAME")
            },
            data = {
                params = {}
            },
        }
    }

local createTemplateFn = function(params)
    local baseLength = trackLengths[params.lPlatform + 1]
    local nbTracks = trackNumberList[params.trackNb + 1]
    local radius = rList[params.radius]
    
    local nSeg = baseLength / 20
    
    local posList = params.platformLeft and ust.posGen(nbTracks, false) or ust.posGen(nbTracks)
    -- local trackType = ("%s%s.module"):format(params.capturedParams.moduleList[params.trackType + 1], params.catenary == 1 and "_catenary" or "")
    local result = {}
    local id = 1
    
    local yMax = nSeg % 2 == 0 and (nSeg / 2 - 1) or (nSeg - 1) / 2
    local yMin = nSeg % 2 == 0 and (-nSeg / 2) or (1 - nSeg) / 2
    
    for i, pos in ipairs(posList) do
        local x = #posList - i
        if pos then
            for y = yMin, yMax do
                local info = {
                    id = id,
                    type = 1,
                    pos = coor.xyz(x, y, 0),
                    length = 20,
                    width = 5,
                }
                local slotId, slotIds = ust.slotIds(info)
                result[slotId] = "station/rail/ust/tracks/high_speed.module"
                for _, slotId in pairs(slotIds) do
                    result[slotId] = "station/rail/ust/ust_data.module"
                end
                id = id + 1
            end
        else
            for y = yMin, yMax do
                local info = {
                    id = id,
                    type = 2,
                    pos = coor.xyz(x, y, 0),
                    length = 20,
                    width = 5,
                }
                local slotId, slotIds = ust.slotIds(info)
                result[slotId] = "station/rail/ust/ust_platform.module"
                for _, slotId in pairs(slotIds) do
                    result[slotId] = "station/rail/ust/ust_data.module"
                end
                id = id + 1
            end
        end
    end
    return result
end

local preProcessFn = function(modules, change)
    local classedModules = classifyModules(modules)
    
    local maxId = 0
    for slotId, module in pairs(modules) do
        module.info = ust.slotInfo(slotId, classedModules)
        if maxId < module.info.id then
            maxId = module.info.id
        end
    end
    
    local info = ust.slotInfo(change.slotId, classedModules)
    local data = change.slotId > 0 and floor(change.slotId / 1000000) or -floor(-change.slotId / 1000000)
    if change.added then
        if (info.type == 1 and data > 0) then
            if (data == 9) then
                local id = info.id
                local slotId = classedModules[id].slotId
                modules[slotId].name = change.module.name
            else
                local dpos = ({
                    [1] = coor.xyz(0, info.pos.y < 0 and -1 or 1, 0),
                    [3] = coor.xyz(1, 0, 0),
                    [5] = coor.xyz(0, info.pos.y < 0 and 1 or -1, 0),
                    [7] = coor.xyz(-1, 0, 0)
                })[data]
                local newInfo = {
                    id = maxId + 1,
                    type = change.module.metadata.typeId,
                    pos = info.pos + dpos,
                    length = 20,
                    width = 5
                }
                local slotId, dataIds = ust.slotIds(newInfo)
                modules[slotId] = change.module
                for key, slotId in pairs(dataIds) do
                    modules[slotId] = {
                        metadata = {isData = true},
                        name = "station/rail/ust/ust_data.module",
                        updateScript = {
                            fileName = "",
                            params = {}
                        },
                        variant = 0
                    }
                end
                for id, m in pairs(modules) do
                    if m.name == "station/rail/ust/ust_radius_modifier.module" then
                        modules[id] = nil
                    end
                end
            end
        elseif (info.type == 2 and data > 0) then
            if (data == 9) then
                local id = info.id
                local slotId = classedModules[id].slotId
                modules[slotId].name = change.module.name
            else
                local dpos = ({
                    [1] = coor.xyz(0, info.pos.y < 0 and -1 or 1, 0),
                    [3] = coor.xyz(1, 0, 0),
                    [5] = coor.xyz(0, info.pos.y < 0 and 1 or -1, 0),
                    [7] = coor.xyz(-1, 0, 0)
                })[data]
                local newInfo = {
                    id = maxId + 1,
                    type = change.module.metadata.typeId,
                    pos = info.pos + dpos,
                    length = 20,
                    width = 5
                }
                local slotId, dataIds = ust.slotIds(newInfo)
                modules[slotId] = change.module
                for key, slotId in pairs(dataIds) do
                    modules[slotId] = {
                        metadata = {isData = true},
                        name = "station/rail/ust/ust_data.module",
                        updateScript = {
                            fileName = "",
                            params = {}
                        },
                        variant = 0
                    }
                end
                for id, m in pairs(modules) do
                    if m.name == "station/rail/ust/ust_radius_modifier.module" then
                        modules[id] = nil
                    end
                end
            end
        elseif info.type == 99 and info.id ~= 1 then
            for _, slotId in pairs(classedModules[info.id].slot) do
                modules[slotId] = nil
            end
            modules[classedModules[info.id].slotId] = nil
            modules[change.slotId] = nil
        elseif info.type == 80 and data == 1 then
            modules[ust.base(info.id, 80)] = nil
        elseif info.type == 80 and data == 0 then
            modules[ust.base(info.id, 80)] = change.module
        elseif info.type >= 81 and info.type <= 86 then
            ust.gridization(modules, classedModules)
            local id = info.id
            local m = modules[classedModules[id].slotId]
            
            if classedModules[id].slot[54] then
                modules[classedModules[id].slot[54]] = nil
            end
            
            if classedModules[id].slot[55] then
                modules[classedModules[id].slot[55]] = nil
            end
            
            if classedModules[id].slot[56] then
                modules[classedModules[id].slot[56]] = nil
            end
            
            modules[classedModules[id].slot[80]].variant = 1 - modules[classedModules[id].slot[80]].variant
            
            if info.type >= 81 and info.type <= 84 then
                local radius = m.info.radius
                
                if info.type == 81 or info.type == 82 then
                    local delta = data > 0 and pow(10, data - 1) or -pow(10, -data - 1)
                    if m.info.radius == 10e8 or m.info.straight then
                        radius = delta
                    else
                        radius = radius + delta
                    end
                else
                    local refArc = m.info.arcs.center
                    local i = data
                    local rad = (refArc.inf - refArc.sup) + i * pi / 180
                    radius = -floor(20 / rad)
                end
                
                if radius > 999999 then radius = 999999 elseif radius < -999999 then radius = -999999 end
                
                local addSlot = ust.mixData(ust.base(id, 54), radius > 0 and radius % 1000 or -(-radius % 1000))
                modules[addSlot] = {
                    metadata = {isData = true},
                    name = "station/rail/ust/ust_data.module",
                    updateScript = {
                        fileName = "",
                        params = {}
                    },
                    variant = 0
                }
                
                local addSlot = ust.mixData(ust.base(id, 55), radius > 0 and floor(radius / 1000) or -(floor(-radius / 1000)))
                modules[addSlot] = {
                    metadata = {isData = true},
                    name = "station/rail/ust/ust_data.module",
                    updateScript = {
                        fileName = "",
                        params = {}
                    },
                    variant = 0
                }
            elseif info.type == 85 or info.type == 86 then
                
                if data == 0 then
                    local addSlot = ust.mixData(ust.base(id, 56), 0)
                    modules[addSlot] = {
                        metadata = {isData = true},
                        name = "station/rail/ust/ust_data.module",
                        updateScript = {
                            fileName = "",
                            params = {}
                        },
                        variant = 0
                    }
                end
            end
        else
            modules[change.slotId] = change.module
        end
    else
        if (info.type == 1 and data == 0) then
            for _, slotId in pairs(classedModules[info.id].slot) do
                modules[slotId] = nil
            end
            modules[change.slotId] = nil
        end
    end
    
    return modules
end

local function searchTerminalGroups(params, current, ...)
    if current == nil then
        return
    end
    
    local m = params.modules[current]
    if m.metadata.isTrack and not m.info.trackGroup then
        local group = {current};
        while m.info.octa[1] and params.modules[m.info.octa[1]].metadata.isTrack do
            group = {m.info.octa[1]}
            m = params.modules[m.info.octa[1]]
        end
        
        while m.info.octa[5] and params.modules[m.info.octa[5]].metadata.isTrack do
            table.insert(group, m.info.octa[5])
            m = params.modules[m.info.octa[5]]
        end

        table.insert(params.trackGroup, group)

        for _, slotId in ipairs(group) do
            params.modules[slotId].info.trackGroup = #params.trackGroup
        end
    end
    searchTerminalGroups(params, ...)
end

local upgradeFn = function(_) end

local updateFn = function(params, closureParams)
    local result = {
        entryConnectors = {},
        colliders = {},
        terrainAlignmentLists = {{type = "EQUAL", faces = {}}},
        groundFaces = {},
        terminalGroups = {},
        stations = {},
        dependentSlots = {},
        edgeLists = {},
        slotConfig = {},
        occupied = {{}, {}, {}, {}},
        cost = 0,
        models = pipe.new * {},
        slots = {},
        labelText = {}
    }
    
    
    params.classedModules = classifyModules(params.modules)
    
    for id, info in pairs(params.classedModules) do
        params.modules[info.slotId].info = ust.slotInfo(info.slotId, params.classedModules)
        params.modules[info.slotId].makeData = function(type, data)
            return ust.mixData(ust.base(id, type), data)
        end
        for id, slotId in pairs(info.slot) do
            params.modules[slotId].info = ust.slotInfo(slotId, params.classedModules)
        end
    end
    
    local grid = ust.gridization(params.modules, params.classedModules)
    
    params.grid = grid
    params.slotGrid = {}

    params.trackGroup = {}
    searchTerminalGroups(params, unpack(func.map(func.sort(func.keys(params.classedModules)), function(id) return params.classedModules[id].slotId end)))

    dump()(params.trackGroup)
    
    params.anyRadiusModifiable = false
    for _, module in pairs(params.modules) do
        params.anyRadiusModifiable = params.anyRadiusModifiable or module.info.canModifyRadius
    end
    
    for slotId, module in pairs(params.modules) do
        if module.metadata.isTrack then
            local baseTransf =
                quat.byVec(coor.xyz(0, module.info.pos.y < 0 and -1 or 1, 0), module.info.gravity[2]):mRot() *
                coor.trans(module.info.gravity[1])
            
            insert(result.slots, {
                id = slotId,
                transf = baseTransf,
                type = "ust_track",
                spacing = {2.5, 2.5, 2.5, 2.5}
            })
        elseif module.metadata.isPlatform then
            insert(result.slots, {
                id = slotId,
                transf = coor.I(),
                type = "ust_platform",
                spacing = {2.5, 2.5, 2.5, 2.5}
            })
        elseif module.metadata.isData then
            insert(result.slots, {
                id = slotId,
                transf = coor.I(),
                type = "ust_data",
                spacing = {0, 0, 0, 0}
            })
        end
    end
    
    result.terminateConstructionHook = function()
            -- dump()(result.slots)
            for _, z in pairs(params.slotGrid) do
                for _, x in pairs(z) do
                    for _, y in pairs(x) do
                        for _, s in pairs(y) do
                            insert(result.slots, s)
                        end
                    end
                end
            end
    end
    return result
end

function data()
    return {
        type = "RAIL_STATION",
        description = {
            name = _("MENU_NAME"),
            description = _("MENU_NAME")
        },
        availability = {
            yearFrom = 0,
            yearTo = 0
        },
        order = 1000,
        constructionTemplates = constructionTemplates,
        createTemplateFn = createTemplateFn,
        params = {
            {
                key = "trackNb",
                name = _("MENU_TRACK_NR"),
                values = func.map(trackNumberList, tostring),
                uiType = "SLIDER",
                defaultIndex = 0
            },
            {
                key = "trackType",
                name = _("MENU_TRACK_TYPE"),
                uiType = "COMBOBOX",
                values = {_("Standard"), _("High-Speed")},
                defaultIndex = 0
            },
            {
                key = "catenary",
                name = _("MENU_TRACK_CAT"),
                values = {_("YES"), _("NO")},
                defaultIndex = 0
            },
            {
                key = "radius",
                name = _("MENU_RADIUS"),
                values = rList * pipe.map(function(r) return r > 15 and "∞" or tostring(math.floor(r * 1000)) end),
                uiType = "SLIDER",
                defaultIndex = (#rList - 1) / 2
            },
            {
                key = "lPlatform",
                name = _("MENU_PLATFORM_LENGTH"),
                values = func.map(trackLengths, tostring),
                uiType = "SLIDER",
                defaultIndex = 0
            },
            {
                key = "hPlatform",
                name = _("MENU_PLATFORM_HEIGHT"),
                values = func.map(hPlatformList, tostring),
                uiType = "SLIDER",
                defaultIndex = 3
            },
            {
                key = "platformWidth",
                name = _("MENU_PLATFORM_WIDTH"),
                values = {"5", "10", "15", "20"},
                defaultIndex = 1
            },
            {
                key = "platformLeft",
                name = _("MENU_PLATFORM_LEFT"),
                values = {_("YES"), _("NO")},
                defaultIndex = 0
            },
            {
                key = "platformRight",
                name = _("MENU_PLATFORM_RIGHT"),
                values = {_("YES"), _("NO"), _("AUTO")},
                defaultIndex = 2
            },
        },
        upgradeFn = upgradeFn,
        updateFn = updateFn,
        preProcessFn = preProcessFn
    }
end
