local func = require "ust/func"
local coor = require "ust/coor"
local arc = require "ust/coorarc"
local quat = require "ust/quaternion"
local pipe = require "ust/pipe"
local general = require "ust/general"
local ust = require "ust"
local dump = require "luadump"
local livetext = require "ust/livetext"

local unpack = table.unpack
local abs = math.abs

local function classifyModules(params)
    local result = {}
    for slotId, m in pairs(params) do
        local slotIdAbs = math.abs(slotId)
        local type = slotIdAbs % 100
        local id = (slotIdAbs - type) / 100 % 10000
        m.typeId = type
        if not result[id] then result[id] = {info = {}, slot = {}} end
        if (type < 50) then
            result[id].type = type
            result[id].slotId = slotId
            result[id].data = slotId > 0 and math.floor(slotIdAbs / 1000000) or -math.floor(slotIdAbs / 1000000)
        else
            local data = slotId > 0 and math.floor(slotIdAbs / 1000000) or -math.floor(slotIdAbs / 1000000)
            result[id].info[type] = data
            result[id].slot[type] = slotId
        end
    end
    return result
end

local constructionTemplates =
    {
        {
            constructionType = "RAIL_STATION",
            type = "DYNAMIC",
            availability = {
                yearFrom = 0,
                yearTo = 0
            },
            description = {
                name = _("MENU_NAME"),
                description = _("MENU_NAME")
            },
            data = {
                params = {}
            },
        }
    }

local arcPacker = function(pt, vec, length, radius)
    local nVec = vec:withZ(0):normalized()
    local tVec = coor.xyz(-nVec.y, nVec.x, 0)
    local o = pt + tVec * radius
    local ar = arc.byOR(o, abs(radius))
    local inf = ar:rad(pt)
    local sup = inf + length / radius
    ar = ar:withLimits({
        sup = sup,
        inf = inf
    })
    return function(...)
        local result = func.map({...}, function(dr)
            return arc.byOR(o, abs(radius + dr), {
                sup = sup,
                inf = inf
            })
        end)
        return ar, table.unpack(result)
    end
end

local createTemplateFn = function(_)
    local result = {
        [101] = "station/rail/ust/ust_track.module",
        [151] = "station/rail/ust/ust_data.module",
        [152] = "station/rail/ust/ust_data.module",
        [153] = "station/rail/ust/ust_data.module",
        [100000154] = "station/rail/ust/ust_data.module",
        [-155] = "station/rail/ust/ust_data.module",
        [20000157] = "station/rail/ust/ust_data.module",
        
        [301] = "station/rail/ust/ust_track.module",
        [351] = "station/rail/ust/ust_data.module",
        [-001000352] = "station/rail/ust/ust_data.module",
        [353] = "station/rail/ust/ust_data.module",
        [-100000354] = "station/rail/ust/ust_data.module",
        [-001000355] = "station/rail/ust/ust_data.module",
        [20000357] = "station/rail/ust/ust_data.module",
    }
    
    return result
end

local preProcessFn = function(modules, change)
    local classedModules = classifyModules(modules)
    
    local maxId = 0
    for slotId, module in pairs(modules) do
        module.info = ust.slotInfo(slotId, classedModules)
        if maxId < module.info.id then
            maxId = module.info.id
        end
    end
    
    if change.added then
        local info = ust.slotInfo(change.slotId, classedModules)
        local data = change.slotId > 0 and math.floor(change.slotId / 1000000) or -math.floor(-change.slotId / 1000000)
        
        if (info.type == 1 and data < 5 and data > 0) then
            local dpos = ({
                coor.xyz(-1, 0, 0),
                coor.xyz(1, 0, 0),
                coor.xyz(0, info.pos.y < 0 and 1 or -1, 0),
                coor.xyz(0, info.pos.y < 0 and -1 or 1, 0)
            })[data]
            local newInfo = {
                id = maxId + 1,
                type = change.module.metadata.typeId,
                pos = info.pos + dpos,
                length = 20,
                width = 5
            }
            local slotId, dataIds = ust.slotIds(newInfo)
            modules[slotId] = change.module
            for key, slotId in pairs(dataIds) do
                modules[slotId] = {
                    metadata = {isData = true},
                    name = "station/rail/ust/ust_data.module",
                    updateScript = {
                        fileName = "",
                        params = {}
                    },
                    variant = 0
                }
            end
        elseif info.type == 80 and data == 1 then
            modules[info.id * 100 + 80] = nil
        elseif info.type == 81 or info.type == 82 then
            local id = info.id
            if classedModules[id].slot[54] then
                modules[classedModules[id].slot[54]] = nil
            end
            
            if classedModules[id].slot[55] then
                modules[classedModules[id].slot[55]] = nil
            end
            
            if classedModules[id].slot[56] then
                modules[classedModules[id].slot[56]] = nil
            end
            
            modules[classedModules[id].slot[80]].variant = 1 - modules[classedModules[id].slot[80]].variant
            
            local radius = (classedModules[id].info[54] or 0) + (classedModules[id].info[55] or 0) * 1000
            local delta = data > 0 and math.pow(10, data - 1) or -math.pow(10, -data - 1)
            radius = radius + delta
            
            if radius > 999999 then radius = 999999 elseif radius < -999999 then radius = -999999 end
            
            local addSlot = ust.mixData(ust.base(id, 54), radius > 0 and radius % 1000 or -(-radius % 1000))
            modules[addSlot] = {
                metadata = {isData = true},
                name = "station/rail/ust/ust_data.module",
                updateScript = {
                    fileName = "",
                    params = {}
                },
                variant = 0
            }
            
            local addSlot = ust.mixData(ust.base(id, 55), radius > 0 and math.floor(radius / 1000) or -(math.floor(-radius / 1000)))
            modules[addSlot] = {
                metadata = {isData = true},
                name = "station/rail/ust/ust_data.module",
                updateScript = {
                    fileName = "",
                    params = {}
                },
                variant = 0
            }
        elseif info.type == 83 or info.type == 84 then
            local id = info.id
            if classedModules[id].slot[54] then
                modules[classedModules[id].slot[54]] = nil
            end
            
            if classedModules[id].slot[55] then
                modules[classedModules[id].slot[55]] = nil
            end
            
            if classedModules[id].slot[56] then
                modules[classedModules[id].slot[56]] = nil
            end
            
            modules[classedModules[id].slot[80]].variant = 1 - modules[classedModules[id].slot[80]].variant
            
            if data == 0 then
                local addSlot = ust.mixData(ust.base(id, 56), 0)
                modules[addSlot] = {
                    metadata = {isData = true},
                    name = "station/rail/ust/ust_data.module",
                    updateScript = {
                        fileName = "",
                        params = {}
                    },
                    variant = 0
                }
            end
        else
            modules[change.slotId] = change.module
        end
    end
    return modules
end

local upgradeFn = function(_) end

local updateFn = function(params)
    local result = {
        entryConnectors = {},
        colliders = {},
        terrainAlignmentLists = {},
        groundFaces = {},
        terminalGroups = {},
        stations = {},
        dependentSlots = {},
        edgeLists = {},
        slotConfig = {},
        occupied = {{}, {}, {}, {}},
        cost = 0,
        models = pipe.new * {},
        slots = {},
        labelText = {}
    }
    
    
    params.classedModules = classifyModules(params.modules)
    
    for id, info in pairs(params.classedModules) do
        params.modules[info.slotId].info = ust.slotInfo(info.slotId, params.classedModules)
        params.modules[info.slotId].makeData = function(type, data)
            return ust.mixData(ust.base(id, type), data)
        end
        for id, slotId in pairs(info.slot) do
            params.modules[slotId].info = ust.slotInfo(slotId, params.classedModules)
        end
    end

    local grid = {}
    for slotId, module in pairs(params.modules) do
        if not module.metadata.isData then
            local info = module.info
            if not grid[info.pos.z] then grid[info.pos.z] = {} end
            if not grid[info.pos.z][info.pos.x] then grid[info.pos.z][info.pos.x] = {} end
            grid[info.pos.z][info.pos.x][info.pos.y] = slotId
        end
    end
    dump()(params.modules)
    for z, zv in pairs(grid) do
        local xPos = func.sort(func.filter(func.keys(zv), function(k) return k >= 0 end))
        local xNeg = func.rev(func.sort(func.filter(func.keys(zv), function(k) return k < 0 end)))
        local xState = false
        
        local processX = function(x)
            if (not xState) then
                xState = {
                    pos = 0,
                    refList = {},
                }
            end
            
            local yPos = func.sort(func.filter(func.keys(grid[z][x]), function(k) return k >= 0 end))
            local yNeg = func.rev(func.sort(func.filter(func.keys(grid[z][x]), function(k) return k < 0 end)))
            
            for _, y in ipairs(func.rev(func.concat(yNeg, yPos))) do
                local slotId = grid[z][x][y]
                local m = params.modules[slotId]
                local w = m.info.width or m.metadata.width
                if w then
                    if xState.width then
                        xState.pos = xState.pos + xState.width * (x < 0 and -0.5 or 0.5)
                    end
                    xState.width = w
                    xState.pos = xState.pos + xState.width * (x < 0 and -0.5 or 0.5)
                    xState.refList[x] = xState.pos
                    break
                end
            end
            
            local processY = function(y)
                local slotId = grid[z][x][y]
                local m = params.modules[slotId]
                
                if grid[z][x][y - 1] then
                    params.modules[grid[z][x][y - 1]].info.next = slotId
                    m.info.prev = grid[z][x][y - 1]
                end
                
                if grid[z][x][y + 1] then
                    params.modules[grid[z][x][y + 1]].info.prev = slotId
                    m.info.next = grid[z][x][y + 1]
                end
                
                if not m.info.width then
                    m.info.width = m.metadata.width or 5
                end
                
                local yState = {}
                
                local width = m.info.width
                local ref = (y > 0 and grid[z][x][y - 1]) or (y < 0 and grid[z][x][y + 1])
                if y == 0 or y == -1 then
                    yState = {
                        pos = coor.xyz(xState.pos, 0, 0),
                        vec = coor.xyz(0, y < 0 and -1 or 1, 0),
                        width = width,
                        radius = m.info.straight and 10e8 or m.info.radius,
                        length = m.info.length
                    }
                elseif ref then
                    yState = {
                        pos = params.modules[ref].info.pts[2][1],
                        vec = params.modules[ref].info.pts[2][2],
                        width = width,
                        radius = m.info.straight and 10e8 or (m.info.radius or params.modules[ref].info.radius),
                        length = m.info.length
                    }
                else
                    for ix = x + (x < 0 and 1 or -1), 0, (x < 0 and 1 or -1) do
                        if grid[z][ix][y] then
                            local pos = params.modules[grid[z][ix][y]].info.pts[1][1]
                            local vec = params.modules[grid[z][ix][y]].info.pts[1][2]
                            
                            yState = {
                                pos = pos + (vec:normalized() .. coor.rotZ((y < 0 and 0.5 or -0.5) * math.pi)) * (xState.pos - xState.refList[ix]),
                                vec = vec,
                                width = width,
                                radius = m.info.straight and 10e8 or m.info.radius,
                                length = m.info.length
                            }
                            break
                        end
                    end
                end
                
                if not yState.radius then
                    if ref then
                        for i = y + (y < 0 and 1 or -1), 0, (y < 0 and 1 or -1) do
                            if grid[z][x] and grid[z][x][i] then
                                yState.radius = params.modules[grid[z][x][i]].info.radius
                                break
                            end
                        end
                    end
                    if not yState.radius then
                        for i = x + (x < 0 and 1 or -1), (x < 0 and func.max(xPos) or func.min(xNeg) or 0), (x < 0 and 1 or -1) do
                            if grid[z][i] and grid[z][i][y] then
                                yState.radius = params.modules[grid[z][i][y]].info.radius + (xState.pos - xState.refList[i])
                                break
                            end
                        end
                    end
                    if not yState.radius then
                        yState.radius = 10e8
                    end
                end
                m.info.radius = yState.radius
                
                local ar, arL, arR =
                    arcPacker(yState.pos, yState.vec, yState.length, y < 0 and -yState.radius or yState.radius)(-yState.width * 0.5, yState.width * 0.5)
                if y < 0 then arL, arR = arR, arL end
                local refArc = {
                    left = arL,
                    right = arR,
                    center = ar
                }
                
                params.modules[slotId].info.arcs = refArc
                
                params.modules[slotId].info.pts = {
                    {
                        refArc.center:pt(refArc.center.inf),
                        refArc.center:tangent(refArc.center.inf)
                    },
                    {
                        refArc.center:pt(refArc.center.sup),
                        refArc.center:tangent(refArc.center.sup)
                    }
                }
                
                yState.vec = y < 0 and -refArc.center:tangent(refArc.center.sup) or refArc.center:tangent(refArc.center.sup)
                yState.pos = refArc.center:pt(refArc.center.sup)
            end
            
            for _, y in ipairs(yPos) do processY(y) end
            yState = false
            for _, y in ipairs(yNeg) do processY(y) end
        end
        
        for _, x in ipairs(xPos) do processX(x) end
        if xState then
            xState.pos = 0
            xState.width = nil
        end
        for _, x in ipairs(xNeg) do processX(x) end
    end
    
    params.anyRadiusModifiable = false
    for _, module in pairs(params.modules) do
        params.anyRadiusModifiable = params.anyRadiusModifiable or module.info.canModifyRadius
    end
    
    for slotId, module in pairs(params.modules) do
        if not module.metadata.isData then
            local refArc = module.info.arcs.center
            local midPt = 0.5 * (refArc.sup + refArc.inf)
            local pos = module.info.pos
            local baseTransf =
                quat.byVec(coor.xyz(0, module.info.pos.y < 0 and -1 or 1, 0), refArc:tangent(midPt)):mRot() *
                coor.trans(refArc:pt(midPt))
            
            table.insert(result.slots, {
                id = slotId,
                transf = baseTransf,
                type = ust.typeList[module.typeId] or "ust_data",
                spacing = {2.5, 2.5, 2.5, 2.5}
            })
            
            if (not params.anyRadiusModifiable) then
                table.insert(result.slots, {
                    id = module.info.id * 100 + 80,
                    transf = baseTransf * coor.transZ(1),
                    type = "ust_modifier",
                    spacing = {1.5, 1.5, 1.5, 1.5}
                })
            elseif (module.info.canModifyRadius) then
                table.insert(result.slots, {
                    id = ust.mixData(ust.base(module.info.id, 80), 1),
                    transf = baseTransf * coor.transZ(1),
                    type = "ust_modifier",
                    spacing = {1.5, 1.5, 1.5, 1.5}
                })
                
                table.insert(result.slots, {
                    id = module.info.id * 100 + 80,
                    transf = baseTransf * coor.transZ(2),
                    type = "ust_modifier",
                    spacing = {1.5, 1.5, 1.5, 1.5}
                })
            end
            
            if not (grid[pos.z][pos.x - 1] and (grid[pos.z][pos.x - 1][pos.y + 1] or grid[pos.z][pos.x - 1][pos.y - 1])) then
                table.insert(result.slots, {
                    id = ust.mixData(slotId, 1),
                    transf = coor.trans(coor.xyz(-module.metadata.width, 0, 0)) * baseTransf,
                    type = "ust_track",
                    spacing = {1.5, 1.5, 1.5, 1.5}
                })
            end
            
            if not (grid[pos.z][pos.x + 1] and (grid[pos.z][pos.x + 1][pos.y + 1] or grid[pos.z][pos.x + 1][pos.y - 1])) then
                table.insert(result.slots, {
                    id = ust.mixData(slotId, 2),
                    transf = coor.trans(coor.xyz(module.metadata.width, 0, 0)) * baseTransf,
                    type = "ust_track",
                    spacing = {1.5, 1.5, 1.5, 1.5}
                })
            end
            
            
            if not grid[pos.z][pos.x][pos.y + (pos.y < 0 and 1 or -1)] then
                local bwPt = refArc.inf - 0.5 * (refArc.sup - refArc.inf)
                table.insert(result.slots, {
                    id = ust.mixData(slotId, 3),
                    transf = quat.byVec(coor.xyz(0, -1, 0), refArc:tangent(bwPt)):mRot() * coor.trans(refArc:pt(bwPt)),
                    type = "ust_track",
                    spacing = {1.5, 1.5, 1.5, 1.5}
                })
            end
            
            if not grid[pos.z][pos.x][pos.y + (pos.y < 0 and -1 or 1)] then
                local fwPt = refArc.sup + 0.5 * (refArc.sup - refArc.inf)
                table.insert(result.slots, {
                    id = ust.mixData(slotId, 4),
                    transf = quat.byVec(coor.xyz(0, 1, 0), refArc:tangent(fwPt)):mRot() * coor.trans(refArc:pt(fwPt)),
                    type = "ust_track",
                    spacing = {1.5, 1.5, 1.5, 1.5}
                })
            end
        else
            table.insert(result.slots, {
                id = slotId,
                transf = coor.I(),
                type = "ust_data",
                spacing = {1.5, 1.5, 1.5, 1.5}
            })
        end
    
    
    
    end
    
    
    for z, gridx in pairs(grid) do
        for x, gridy in pairs(gridx) do
            local ys = func.keys(gridy)
            local min = func.min(ys)
            local max = func.max(ys)
        
        end
    end
    
    
    
    
    result.terminateConstructionHook = function()
        end
    return result
end

function data()
    
    return {
        type = "RAIL_STATION",
        description = {
            name = _("MENU_NAME"),
            description = _("MENU_NAME")
        },
        availability = {
            yearFrom = 0,
            yearTo = 0
        },
        order = 1000,
        constructionTemplates = constructionTemplates,
        createTemplateFn = createTemplateFn,
        params = {
        },
        upgradeFn = upgradeFn,
        updateFn = updateFn,
        preProcessFn = preProcessFn
    }
end
