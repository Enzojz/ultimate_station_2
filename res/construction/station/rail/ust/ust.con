local func = require "ust/func"
local coor = require "ust/coor"
local arc = require "ust/coorarc"
local line = require "ust/coorline"
local quat = require "ust/quaternion"
local pipe = require "ust/pipe"
local general = require "ust/general"
local ust = require "ust"
local dump = require "luadump"
local livetext = require "ust/livetext"

local unpack = table.unpack
local insert = table.insert
local abs = math.abs
local pow = math.pow
local floor = math.floor
local pi = math.pi

local arcPacker = function(pt, vec, length, radius)
    local nVec = vec:withZ(0):normalized()
    local tVec = coor.xyz(-nVec.y, nVec.x, 0)
    local o = pt + tVec * radius
    local ar = arc.byOR(o, abs(radius))
    local inf = ar:rad(pt)
    local sup = inf + length / radius
    ar = ar:withLimits({
        sup = sup,
        inf = inf
    })
    return function(...)
        local result = func.map({...}, function(dr)
            return arc.byOR(o, abs(radius + dr), {
                sup = sup,
                inf = inf
            })
        end)
        return ar, unpack(result)
    end
end

local function classifyModules(params)
    local result = {}
    for slotId, m in pairs(params) do
        local slotIdAbs = abs(slotId)
        local type = slotIdAbs % 100
        local id = (slotIdAbs - type) / 100 % 10000
        m.typeId = type
        if not result[id] then result[id] = {info = {}, slot = {}} end
        if (type < 50) then
            result[id].type = type
            result[id].slotId = slotId
            result[id].data = slotId > 0 and floor(slotIdAbs / 1000000) or -floor(slotIdAbs / 1000000)
        else
            local data = slotId > 0 and floor(slotIdAbs / 1000000) or -floor(slotIdAbs / 1000000)
            result[id].info[type] = data
            result[id].slot[type] = slotId
        end
    end
    return result
end

local calculateLimit = function(arc)
    return function(l, ptvec)
        local pt = func.min(arc / l, function(lhs, rhs) return (lhs - ptvec[1]):length2() < (rhs - ptvec[1]):length2() end)
        return arc:rad(pt)
    end
end

local function gridization(modules, classedModules)
    local grid = {}
    for id, info in pairs(classedModules) do
        modules[info.slotId].info = ust.slotInfo(info.slotId, classedModules)
        modules[info.slotId].makeData = function(type, data)
            return ust.mixData(ust.base(id, type), data)
        end
        for id, slotId in pairs(info.slot) do
            modules[slotId].info = ust.slotInfo(slotId, classedModules)
        end
    end
    
    for slotId, module in pairs(modules) do
        if not module.metadata.isData then
            local info = module.info
            if not grid[info.pos.z] then grid[info.pos.z] = {} end
            if not grid[info.pos.z][info.pos.x] then grid[info.pos.z][info.pos.x] = {} end
            grid[info.pos.z][info.pos.x][info.pos.y] = slotId
        end
    end
    
    for z, zv in pairs(grid) do
        local xPos = func.sort(func.filter(func.keys(zv), function(k) return k >= 0 end))
        local xNeg = func.rev(func.sort(func.filter(func.keys(zv), function(k) return k < 0 end)))
        local xState = false
        
        local processY = function(x, y)
            return function()
                local slotId = grid[z][x][y]
                local m = modules[slotId]
                
                do
                    if grid[z][x][y - 1] then
                        modules[grid[z][x][y - 1]].info.octa[1] = slotId
                        m.info.octa[5] = grid[z][x][y - 1]
                    end
                    
                    if grid[z][x][y + 1] then
                        modules[grid[z][x][y + 1]].info.octa[5] = slotId
                        m.info.octa[1] = grid[z][x][y + 1]
                    end
                    
                    if grid[z][x - 1] and grid[z][x - 1][y] then
                        modules[grid[z][x - 1][y]].info.octa[3] = slotId
                        m.info.octa[7] = grid[z][x - 1][y]
                    end
                    
                    if grid[z][x + 1] and grid[z][x + 1][y] then
                        modules[grid[z][x + 1][y]].info.octa[7] = slotId
                        m.info.octa[3] = grid[z][x + 1][y]
                    end
                    
                    if grid[z][x - 1] and grid[z][x - 1][y - 1] then
                        modules[grid[z][x - 1][y - 1]].info.octa[2] = slotId
                        m.info.octa[6] = grid[z][x - 1][y - 1]
                    end
                    
                    if grid[z][x + 1] and grid[z][x + 1][y - 1] then
                        modules[grid[z][x + 1][y - 1]].info.octa[8] = slotId
                        m.info.octa[4] = grid[z][x + 1][y - 1]
                    end
                    
                    if grid[z][x - 1] and grid[z][x - 1][y + 1] then
                        modules[grid[z][x - 1][y + 1]].info.octa[4] = slotId
                        m.info.octa[8] = grid[z][x - 1][y + 1]
                    end
                    
                    if grid[z][x + 1] and grid[z][x + 1][y + 1] then
                        modules[grid[z][x + 1][y + 1]].info.octa[6] = slotId
                        m.info.octa[2] = grid[z][x + 1][y + 1]
                    end
                    
                end
                
                if m.metadata.isTrack or m.metadata.isPlatform then
                    if not m.info.width then
                        m.info.width = m.metadata.width or 5
                    end
                    
                    local yState = {}
                    
                    local width = m.info.width
                    local yRef = y < 0 and m.info.octa[1] or (y > 0 and m.info.octa[5])
                    
                    if y == 0 or y == -1 then
                        yState = {
                            pos = coor.xyz(xState.refList[x], 0, 0),
                            vec = coor.xyz(0, y < 0 and -1 or 1, 0),
                            width = width,
                            radius = m.info.straight and 10e8 or m.info.radius,
                            length = m.info.length
                        }
                    elseif yRef then
                        yState = {
                            pos = modules[yRef].info.pts[2][1],
                            vec = modules[yRef].info.pts[2][2],
                            width = width,
                            radius = m.info.straight and 10e8 or (m.info.radius or modules[yRef].info.radius),
                            length = m.info.length,
                        }
                    else
                        for ix = x + (x < 0 and 1 or -1), 0, (x < 0 and 1 or -1) do
                            if grid[z][ix][y] then
                                local pos = modules[grid[z][ix][y]].info.pts[1][1]
                                local vec = modules[grid[z][ix][y]].info.pts[1][2]
                                
                                yState = {
                                    pos = pos + (vec:normalized() .. coor.rotZ((y < 0 and 0.5 or -0.5) * pi)) * (xState.refList[x] - xState.refList[ix]),
                                    vec = vec,
                                    width = width,
                                    radius = m.info.straight and 10e8 or m.info.radius,
                                    length = m.info.length
                                }
                                break
                            end
                        end
                    end
                    
                    if not yState.radius then
                        if yRef then
                            for i = y + (y < 0 and 1 or -1), 0, (y < 0 and 1 or -1) do
                                if grid[z][x] and grid[z][x][i] then
                                    yState.radius = modules[grid[z][x][i]].info.radius
                                    break
                                end
                            end
                        end
                        if not yState.radius then
                            local loop = {}
                            if m.metadata.isTrack then
                                loop = {x + (x < 0 and 1 or -1), (x < 0 and func.max(xPos) or func.min(xNeg) or 0), (x < 0 and 1 or -1)}
                            elseif m.metadata.isPlatform then
                                if (x < 0) then
                                    if m.info.octa[3] and m.info.octa[7] and modules[m.info.octa[3]].metadata.isPlatform and modules[m.info.octa[7]].metadata.isTrack and modules[m.info.octa[7]].info.radius then
                                        loop = {x - 1, func.min(xNeg), -1}
                                    else
                                        loop = {x + 1, func.max(xPos) or 0, 1}
                                    end
                                else
                                    if m.info.octa[7] and m.info.octa[3] and modules[m.info.octa[7]].metadata.isPlatform and modules[m.info.octa[3]].metadata.isTrack and modules[m.info.octa[3]].info.radius then
                                        loop = {x + 1, func.max(xPos), 1}
                                    else
                                        loop = {x - 1, func.min(xNeg) or 0, -1}
                                    end
                                end
                            end
                            for i = loop[1], loop[2], loop[3] do
                                if grid[z][i] and grid[z][i][y] then
                                    yState.radius = modules[grid[z][i][y]].info.radius + (xState.refList[x] - xState.refList[i])
                                    yState.radiusRef = i
                                    break
                                end
                            end
                        end
                        if not yState.radius then
                            yState.radius = 10e8
                        end
                    end
                    
                    modules[slotId].info.radius = yState.radius
                    modules[slotId].info.length = yState.length
                    
                    if (m.metadata.isPlatform) then
                        coroutine.yield()
                        
                        local function findLeftTrack(slotId)
                            if not slotId or not modules[slotId] then
                                return nil
                            elseif modules[slotId].metadata.isTrack then
                                return modules[slotId].info.pos
                            elseif modules[slotId].metadata.isPlatform then
                                return findLeftTrack(modules[slotId].info.octa[7])
                            else
                                return nil
                            end
                        end
                        
                        local function findRightTrack(slotId)
                            if not slotId or not modules[slotId] then
                                return nil
                            elseif modules[slotId].metadata.isTrack then
                                return modules[slotId].info.pos
                            elseif modules[slotId].metadata.isPlatform then
                                return findRightTrack(modules[slotId].info.octa[3])
                            else
                                return nil
                            end
                        end
                        
                        local leftTrackPos = findLeftTrack(slotId)
                        local rightTrackPos = findRightTrack(slotId)
                        
                        local ref = {
                            left = (leftTrackPos and not rightTrackPos) or (leftTrackPos and rightTrackPos and leftTrackPos.x == x - 1 and rightTrackPos.x ~= x + 1),
                            right = (rightTrackPos and not leftTrackPos) or (leftTrackPos and rightTrackPos and leftTrackPos.x ~= x - 1 and rightTrackPos.x == x + 1),
                            leftRight = leftTrackPos and rightTrackPos and leftTrackPos.x == x - 1 and rightTrackPos.x == x + 1,
                        }
                        
                        if y >= 0 then
                            if (x >= 0) then
                                if (ref.left and not ref.right and leftTrackPos ~= x - 1) then
                                    if (m.info.octa[5] and modules[m.info.octa[5]].metadata.isPlatform and modules[m.info.octa[5]].info.ref and modules[m.info.octa[5]].info.ref.right) then
                                        ref = {prev = true}
                                    end
                                end
                            else
                                if (ref.right and not ref.left and rightTrackPos ~= x + 1) then
                                    if (m.info.octa[5] and modules[m.info.octa[5]].metadata.isPlatform and modules[m.info.octa[5]].info.ref and modules[m.info.octa[5]].info.ref.left) then
                                        ref = {prev = true}
                                    end
                                end
                            end
                        else
                            if (x >= 0) then
                                if (ref.left and not ref.right and leftTrackPos ~= x - 1) then
                                    if (m.info.octa[1] and modules[m.info.octa[1]].metadata.isPlatform and modules[m.info.octa[1]].info.ref and modules[m.info.octa[1]].info.ref.right) then
                                        ref = {next = true}
                                    end
                                end
                            else
                                if (not ref.leftRight and m.info.octa[1] and modules[m.info.octa[1]].metadata.isPlatform and modules[m.info.octa[1]].info.ref and modules[m.info.octa[1]].info.ref.leftRight) then
                                    ref = {next = true}
                                elseif (ref.right and not ref.left and rightTrackPos ~= x + 1) then
                                    if (m.info.octa[1] and modules[m.info.octa[1]].metadata.isPlatform and modules[m.info.octa[1]].info.ref and modules[m.info.octa[1]].info.ref.left) then
                                        ref = {next = true}
                                    end
                                end
                            end
                        end
                        
                        modules[slotId].info.ref = ref
                        
                        local packer = arcPacker(yState.pos, yState.vec, yState.length, y < 0 and -yState.radius or yState.radius)
                        local ar, arL, arR = packer(-yState.width * 0.5, yState.width * 0.5)
                        if y < 0 then arL, arR = arR, arL end
                        
                        local aligned = false;
                        
                        if ref.leftRight then
                            local leftTrack = modules[grid[z][leftTrackPos.x][y]]
                            local leftO = leftTrack.info.arcs.center.o
                            local leftRadius = leftTrack.info.radius + (xState.refList[x] - xState.refList[leftTrackPos.x])
                            arL = arc.byOR(leftO, leftRadius - m.info.width * 0.5, leftTrack.info.arcs.center:limits())
                            
                            local rightTrack = modules[grid[z][rightTrackPos.x][y]]
                            local rightO = rightTrack.info.arcs.center.o
                            local rightRadius = rightTrack.info.radius + (xState.refList[x] - xState.refList[rightTrackPos.x])
                            arR = arc.byOR(rightO, rightRadius + m.info.width * 0.5, rightTrack.info.arcs.center:limits())
                            
                            local sup = leftTrack.info.pts[2][1]:avg(rightTrack.info.pts[2][1])
                            
                            local vecSupL = (leftTrack.info.radius > 0 and (leftTrack.info.pts[2][1] - arL.o) or (arL.o - leftTrack.info.pts[2][1])):normalized()
                            local vecSupR = (rightTrack.info.radius > 0 and (rightTrack.info.pts[2][1] - arR.o) or (arR.o - rightTrack.info.pts[2][1])):normalized()
                            local vecSup = (vecSupL + vecSupR):normalized()
                            local limitSup = line.byVecPt(vecSup, sup)
                            
                            supL = calculateLimit(arL)(limitSup, leftTrack.info.pts[2])
                            supR = calculateLimit(arR)(limitSup, rightTrack.info.pts[2])
                            
                            local infL = arL:rad(yState.pos)
                            if (y == 0 or y == -1) then
                                infL = leftTrack.info.arcs.center.inf
                            elseif (y > 0 and m.info.octa[5]) then
                                infL = arL:rad(modules[m.info.octa[5]].info.pts[2][1])
                            elseif (y < 0 and m.info.octa[1]) then
                                infL = arL:rad(modules[m.info.octa[1]].info.pts[2][1])
                            end
                            
                            local infR = arR:rad(yState.pos)
                            if (y == 0 or y == -1) then
                                infR = rightTrack.info.arcs.center.inf
                            elseif (y > 0 and m.info.octa[5]) then
                                infR = arR:rad(modules[m.info.octa[5]].info.pts[2][1])
                            elseif (y < 0 and m.info.octa[1]) then
                                infR = arR:rad(modules[m.info.octa[1]].info.pts[2][1])
                            end
                            
                            arL = arL:withLimits({sup = supL, inf = infL})
                            arR = arR:withLimits({sup = supR, inf = infR})
                            aligned = true
                        elseif ref.left then
                            local leftTrack = modules[grid[z][leftTrackPos.x][y]]
                            local leftO = leftTrack.info.arcs.center.o
                            local leftRadius = leftTrack.info.radius + (xState.refList[x] - xState.refList[leftTrackPos.x])
                            arL = arc.byOR(leftO, leftRadius - m.info.width * 0.5, leftTrack.info.arcs.center:limits())
                            arR = arc.byOR(leftO, leftRadius + m.info.width * 0.5, leftTrack.info.arcs.center:limits())
                            
                            local limitSup = leftTrack.info.limits[2]
                            local supL = calculateLimit(arL)(limitSup, leftTrack.info.pts[2])
                            local supR = calculateLimit(arR)(limitSup, leftTrack.info.pts[2])
                            
                            local inf = arL:rad(yState.pos)
                            if (y == 0 or y == -1) then
                                inf = leftTrack.info.arcs.center.inf
                            elseif (y > 0 and m.info.octa[5]) then
                                inf = arL:rad(modules[m.info.octa[5]].info.pts[2][1])
                            elseif (y < 0 and m.info.octa[1]) then
                                inf = arL:rad(modules[m.info.octa[1]].info.pts[2][1])
                            end
                            
                            arL = arL:withLimits({sup = supL, inf = inf})
                            arR = arR:withLimits({sup = supR, inf = inf})
                            aligned = true
                        elseif ref.right then
                            local rightTrack = modules[grid[z][rightTrackPos.x][y]]
                            local rightO = rightTrack.info.arcs.center.o
                            local rightRadius = rightTrack.info.radius + (xState.refList[x] - xState.refList[rightTrackPos.x])
                            arL = arc.byOR(rightO, rightRadius - m.info.width * 0.5, rightTrack.info.arcs.center:limits())
                            arR = arc.byOR(rightO, rightRadius + m.info.width * 0.5, rightTrack.info.arcs.center:limits())
                            
                            local limitSup = rightTrack.info.limits[2]
                            local supL = calculateLimit(arL)(limitSup, rightTrack.info.pts[2])
                            local supR = calculateLimit(arR)(limitSup, rightTrack.info.pts[2])
                            
                            local inf = arL:rad(yState.pos)
                            if (y == 0 or y == -1) then
                                inf = rightTrack.info.arcs.center.inf
                            elseif (y > 0 and m.info.octa[5]) then
                                inf = arL:rad(modules[m.info.octa[5]].info.pts[2][1])
                            elseif (y < 0 and m.info.octa[1]) then
                                inf = arL:rad(modules[m.info.octa[1]].info.pts[2][1])
                            end
                            
                            arL = arL:withLimits({sup = supL, inf = inf})
                            arR = arR:withLimits({sup = supR, inf = inf})
                            aligned = true
                        elseif ref.prev then
                            local arcs = modules[m.info.octa[5]].info.arcs
                            
                            arL = arc.byOR(arcs.left.o, arcs.left.r, arcs.left:limits())
                            arR = arc.byOR(arcs.right.o, arcs.right.r, arcs.right:limits())
                            
                            arL = arL:withLimits({
                                inf = arL.sup,
                                sup = arL.sup + arL.sup - arL.inf
                            })
                            
                            arR = arR:withLimits({
                                inf = arR.sup,
                                sup = arR.sup - arR.inf + arR.sup
                            })
                            
                            aligned = true
                        elseif ref.next then
                            local arcs = modules[m.info.octa[1]].info.arcs
                            
                            arL = arc.byOR(arcs.left.o, arcs.left.r, arcs.left:limits())
                            arR = arc.byOR(arcs.right.o, arcs.right.r, arcs.right:limits())
                            
                            arL = arL:withLimits({
                                inf = arL.sup,
                                sup = arL.sup + arL.sup - arL.inf
                            })
                            
                            arR = arR:withLimits({
                                inf = arR.sup,
                                sup = arR.sup - arR.inf + arR.sup
                            })
                            
                            aligned = true
                        end
                        
                        if aligned then
                            local pts = {
                                arL:pt(arL.inf):avg(arR:pt(arR.inf)),
                                nil,
                                arL:pt(arL.sup):avg(arR:pt(arR.sup))
                            }
                            pts[2] = arL:ptByPt(pts[1]:avg(pts[3])):avg(arR:ptByPt(pts[1]:avg(pts[3])))
                            local midPts = {
                                pts[1]:avg(pts[2]),
                                pts[3]:avg(pts[2])
                            }
                            
                            local lines = {
                                line.pend(line.byPtPt(pts[1], pts[2]), midPts[1]),
                                line.pend(line.byPtPt(pts[3], pts[2]), midPts[2]),
                            }
                            
                            local o = (lines[1] - lines[2]):withZ(0)
                            
                            if not o then
                                local r = 10e8
                                local midPt = pts[1]:avg(pts[3])
                                local chord = line.pend(line.byPtPt(pts[1], pts[3]), midPt)
                                o = pts[2] + (chord - pts[2]):normalized() * r
                            end
                            
                            local vecInf = pts[1] - o
                            local vecSup = pts[3] - o
                            
                            local r = vecInf:length()
                            if r > 10e8 then r = 10e8 end
                            ar = arc.byOR(o, r)
                            
                            local inf = ar:rad(pts[1])
                            
                            local length = math.asin(vecInf:cross(vecSup).z / (r * r)) * r
                            local sup = inf + length / r
                            ar = ar:withLimits({
                                sup = sup,
                                inf = inf
                            })
                            
                            modules[slotId].info.radius = (length > 0 and 1 or -1) * (y < 0 and -1 or 1) * r
                            modules[slotId].info.length = math.abs(length)
                        end
                        
                        
                        local refArc = {
                            left = arL,
                            right = arR,
                            center = ar
                        }
                        
                        modules[slotId].info.arcs = refArc
                        modules[slotId].info.pts = {
                            {
                                refArc.center:pt(refArc.center.inf),
                                refArc.center:tangent(refArc.center.inf)
                            },
                            {
                                refArc.center:pt(refArc.center.sup),
                                refArc.center:tangent(refArc.center.sup)
                            }
                        }
                        modules[slotId].info.gravity = {
                            refArc.center:pt((refArc.center.inf + refArc.center.sup) * 0.5),
                            refArc.center:tangent((refArc.center.inf + refArc.center.sup) * 0.5)
                        }
                    else
                        local packer = arcPacker(yState.pos, yState.vec, yState.length, y < 0 and -yState.radius or yState.radius)
                        local ar, arL, arR = packer(-yState.width * 0.5, yState.width * 0.5)
                        if y < 0 then arL, arR = arR, arL end
                        
                        if x < 0 and m.info.octa[3] and modules[m.info.octa[3]].metadata.isTrack then
                            if (y >= 0 and m.info.octa[1] and modules[m.info.octa[1]].metadata.isPlatform)
                                or (y < 0 and m.info.octa[5] and modules[m.info.octa[5]].metadata.isPlatform) then
                                local sup = modules[m.info.octa[3]].info.arcs.center.sup
                                arL.sup = sup
                                arR.sup = sup
                                ar.sup = sup
                            elseif (y >= 0 and m.info.octa[5] and modules[m.info.octa[5]].metadata.isPlatform)
                                or (y < 0 and m.info.octa[1] and modules[m.info.octa[1]].metadata.isPlatform) then
                                local inf = modules[m.info.octa[3]].info.arcs.center.inf
                                arL.inf = inf
                                arR.inf = inf
                                ar.inf = inf
                            end
                        elseif x >= 0 and m.info.octa[7] and modules[m.info.octa[7]].metadata.isTrack then
                            if (y >= 0 and m.info.octa[1] and modules[m.info.octa[1]].metadata.isPlatform)
                                or (y < 0 and m.info.octa[5] and modules[m.info.octa[5]].metadata.isPlatform) then
                                local sup = modules[m.info.octa[7]].info.arcs.center.sup
                                arL.sup = sup
                                arR.sup = sup
                                ar.sup = sup
                            elseif (y >= 0 and m.info.octa[5] and modules[m.info.octa[5]].metadata.isPlatform)
                                or (y < 0 and m.info.octa[1] and modules[m.info.octa[1]].metadata.isPlatform) then
                                local inf = modules[m.info.octa[7]].info.arcs.center.inf
                                arL.inf = inf
                                arR.inf = inf
                                ar.inf = inf
                            end
                        end
                        
                        local refArc = {
                            left = arL,
                            right = arR,
                            center = ar
                        }
                        
                        modules[slotId].info.arcs = refArc
                        
                        modules[slotId].info.pts = {
                            {
                                refArc.center:pt(refArc.center.inf),
                                refArc.center:tangent(refArc.center.inf)
                            },
                            {
                                refArc.center:pt(refArc.center.sup),
                                refArc.center:tangent(refArc.center.sup)
                            }
                        }
                        modules[slotId].info.gravity = {
                            refArc.center:pt((refArc.center.inf + refArc.center.sup) * 0.5),
                            refArc.center:tangent((refArc.center.inf + refArc.center.sup) * 0.5)
                        }
                        modules[slotId].info.limits = func.map(modules[slotId].info.pts, function(ptvec) return line.byVecPt(ptvec[2] .. coor.rotZ(0.5 * pi), ptvec[1]) end)
                    end
                
                end
            end
        end
        
        local fnY = {}
        local xGroup = {}
        
        local processX = function(x)
            if (not xState) then
                xState = {
                    pos = 0,
                    refList = {},
                }
            end
            
            local yList = func.concat(
                func.sort(func.filter(func.keys(grid[z][x]), function(k) return k >= 0 end)),
                func.rev(func.sort(func.filter(func.keys(grid[z][x]), function(k) return k < 0 end)))
            )
            local width = nil
            for _, y in ipairs(func.rev(yList)) do
                local slotId = grid[z][x][y]
                local m = modules[slotId]
                local w = m.info.width or m.metadata.width
                if not width or width < w then
                    width = w
                end
            end
            
            if width then
                if xState.width then
                    xState.pos = xState.pos + xState.width * (x < 0 and -0.5 or 0.5)
                end
                xState.width = width
                xState.pos = xState.pos + xState.width * (x < 0 and -0.5 or 0.5)
                xState.refList[x] = xState.pos
            end
            
            for _, y in ipairs(yList) do
                if not fnY[y] then fnY[y] = {} end
                table.insert(fnY[y], coroutine.create(processY(x, y)))
            end
            
            local sortedY = func.sort(yList)
            for i, y in ipairs(sortedY) do
                if xGroup[x] then
                    if y - sortedY[i - 1] == 1 then
                        table.insert(xGroup[x][#xGroup[x]], y)
                    else
                        table.insert(xGroup[x], {y})
                    end
                else
                    xGroup[x] = {{y}}
                end
            end
        end
        
        for _, x in ipairs(xPos) do
            processX(x)
        end
        if xState then
            xState.pos = 0
            xState.width = nil
        end
        for _, x in ipairs(xNeg) do processX(x) end
        
        for x, groups in pairs(xGroup) do
            for _, group in ipairs(groups) do
                for _, y in ipairs(group) do
                    local m = modules[grid[z][x][y]]
                    local left = grid[z][x - 1] and modules[grid[z][x - 1][y]]
                    local right = grid[z][x + 1] and modules[grid[z][x + 1][y]]
                
                end
            end
        end
        
        
        local yList = func.concat(
            func.sort(func.filter(func.keys(fnY), function(k) return k >= 0 end)),
            func.rev(func.sort(func.filter(func.keys(fnY), function(k) return k < 0 end)))
        )
        for _, y in ipairs(yList) do
            for _, fn in ipairs(fnY[y]) do
                coroutine.resume(fn)
            end
            
            for _, fn in ipairs(fnY[y]) do
                local result = coroutine.resume(fn)
                if not result then
                    print(debug.traceback(fn))
                end
            end
        end
    end
    return grid
end

local constructionTemplates =
    {
        {
            constructionType = "RAIL_STATION",
            type = "DYNAMIC",
            availability = {
                yearFrom = 0,
                yearTo = 0
            },
            description = {
                name = _("MENU_NAME"),
                description = _("MENU_NAME")
            },
            data = {
                params = {}
            },
        }
    }

local createTemplateFn = function(_)
    local result = {
        [101] = "station/rail/ust/ust_track.module",
        [151] = "station/rail/ust/ust_data.module",
        [152] = "station/rail/ust/ust_data.module",
        [153] = "station/rail/ust/ust_data.module",
        [100000154] = "station/rail/ust/ust_data.module",
        [-155] = "station/rail/ust/ust_data.module",
        [20000157] = "station/rail/ust/ust_data.module",
    
    -- [201] = "station/rail/ust/ust_platform.module",
    -- [1000251] = "station/rail/ust/ust_data.module",
    -- [252] = "station/rail/ust/ust_data.module",
    -- [253] = "station/rail/ust/ust_data.module",
    -- [20000257] = "station/rail/ust/ust_data.module",
    -- [10000258] = "station/rail/ust/ust_data.module",
    -- [502] = "station/rail/ust/ust_track.module",
    -- [1000551] = "station/rail/ust/ust_data.module",
    -- [-1000552] = "station/rail/ust/ust_data.module",
    -- [553] = "station/rail/ust/ust_data.module",
    -- [20000557] = "station/rail/ust/ust_data.module",
    -- [10000558] = "station/rail/ust/ust_data.module",
    -- [401] = "station/rail/ust/ust_track.module",
    -- [2000451] = "station/rail/ust/ust_data.module",
    -- [452] = "station/rail/ust/ust_data.module",
    -- [453] = "station/rail/ust/ust_data.module",
    -- [20000457] = "station/rail/ust/ust_data.module",
    -- [301] = "station/rail/ust/ust_track.module",
    -- [351] = "station/rail/ust/ust_data.module",
    -- [-001000352] = "station/rail/ust/ust_data.module",
    -- [353] = "station/rail/ust/ust_data.module",
    -- [-100000354] = "station/rail/ust/ust_data.module",
    -- [-001000355] = "station/rail/ust/ust_data.module",
    -- [20000357] = "station/rail/ust/ust_data.module",
    }
    
    return result
end

local preProcessFn = function(modules, change)
    local classedModules = classifyModules(modules)
    
    local maxId = 0
    for slotId, module in pairs(modules) do
        module.info = ust.slotInfo(slotId, classedModules)
        if maxId < module.info.id then
            maxId = module.info.id
        end
    end
    
    local info = ust.slotInfo(change.slotId, classedModules)
    local data = change.slotId > 0 and floor(change.slotId / 1000000) or -floor(-change.slotId / 1000000)
    if change.added then
        
        if (info.type == 1 and data < 5 and data > 0) then
            local dpos = ({
                coor.xyz(-1, 0, 0),
                coor.xyz(1, 0, 0),
                coor.xyz(0, info.pos.y < 0 and 1 or -1, 0),
                coor.xyz(0, info.pos.y < 0 and -1 or 1, 0)
            })[data]
            local newInfo = {
                id = maxId + 1,
                type = change.module.metadata.typeId,
                pos = info.pos + dpos,
                length = 20,
                width = 5
            }
            local slotId, dataIds = ust.slotIds(newInfo)
            modules[slotId] = change.module
            for key, slotId in pairs(dataIds) do
                modules[slotId] = {
                    metadata = {isData = true},
                    name = "station/rail/ust/ust_data.module",
                    updateScript = {
                        fileName = "",
                        params = {}
                    },
                    variant = 0
                }
            end
            for id, m in pairs(modules) do
                if m.name == "station/rail/ust/ust_radius_modifier.module" then
                    modules[id] = nil
                end
            end
        elseif (info.type == 2 and data < 5 and data > 0) then
            local dpos = ({
                coor.xyz(-1, 0, 0),
                coor.xyz(1, 0, 0),
                coor.xyz(0, info.pos.y < 0 and 1 or -1, 0),
                coor.xyz(0, info.pos.y < 0 and -1 or 1, 0)
            })[data]
            local newInfo = {
                id = maxId + 1,
                type = change.module.metadata.typeId,
                pos = info.pos + dpos,
                length = 20,
                width = 5
            }
            local slotId, dataIds = ust.slotIds(newInfo)
            modules[slotId] = change.module
            for key, slotId in pairs(dataIds) do
                modules[slotId] = {
                    metadata = {isData = true},
                    name = "station/rail/ust/ust_data.module",
                    updateScript = {
                        fileName = "",
                        params = {}
                    },
                    variant = 0
                }
            end
            for id, m in pairs(modules) do
                if m.name == "station/rail/ust/ust_radius_modifier.module" then
                    modules[id] = nil
                end
            end
        elseif info.type == 99 and info.id ~= 1 then
            for _, slotId in pairs(classedModules[info.id].slot) do
                modules[slotId] = nil
            end
            modules[classedModules[info.id].slotId] = nil
            modules[change.slotId] = nil
        elseif info.type == 80 and data == 1 then
            modules[ust.base(info.id, 80)] = nil
            modules[change.slotId] = change.module
        elseif info.type == 80 and data == 2 then
            modules[ust.mixData(ust.base(info.id, 80), 1)] = nil
        elseif info.type >= 81 and info.type <= 86 then
            local grid = gridization(modules, classedModules)
            local id = info.id
            local m = modules[classedModules[id].slotId]
            
            if classedModules[id].slot[54] then
                modules[classedModules[id].slot[54]] = nil
            end
            
            if classedModules[id].slot[55] then
                modules[classedModules[id].slot[55]] = nil
            end
            
            if classedModules[id].slot[56] then
                modules[classedModules[id].slot[56]] = nil
            end
            
            modules[classedModules[id].slot[80]].variant = 1 - modules[classedModules[id].slot[80]].variant
            
            if info.type >= 81 and info.type <= 84 then
                
                local radius = m.info.radius
                
                if info.type == 81 or info.type == 82 then
                    local delta = data > 0 and pow(10, data - 1) or -pow(10, -data - 1)
                    if m.info.radius == 10e8 or m.info.straight then
                        radius = delta
                    else
                        radius = radius + delta
                    end
                else
                    local refArc = m.info.arcs.center
                    local i = data
                    local rad = (refArc.inf - refArc.sup) + i * pi / 180
                    radius = -floor(20 / rad)
                end
                
                if radius > 999999 then radius = 999999 elseif radius < -999999 then radius = -999999 end
                
                local addSlot = ust.mixData(ust.base(id, 54), radius > 0 and radius % 1000 or -(-radius % 1000))
                modules[addSlot] = {
                    metadata = {isData = true},
                    name = "station/rail/ust/ust_data.module",
                    updateScript = {
                        fileName = "",
                        params = {}
                    },
                    variant = 0
                }
                
                local addSlot = ust.mixData(ust.base(id, 55), radius > 0 and floor(radius / 1000) or -(floor(-radius / 1000)))
                modules[addSlot] = {
                    metadata = {isData = true},
                    name = "station/rail/ust/ust_data.module",
                    updateScript = {
                        fileName = "",
                        params = {}
                    },
                    variant = 0
                }
            elseif info.type == 85 or info.type == 86 then
                
                if data == 0 then
                    local addSlot = ust.mixData(ust.base(id, 56), 0)
                    modules[addSlot] = {
                        metadata = {isData = true},
                        name = "station/rail/ust/ust_data.module",
                        updateScript = {
                            fileName = "",
                            params = {}
                        },
                        variant = 0
                    }
                end
            end
        else
            modules[change.slotId] = change.module
        end
    else
        if (info.type == 1 and data == 0) then
            for _, slotId in pairs(classedModules[info.id].slot) do
                modules[slotId] = nil
            end
            modules[change.slotId] = nil
        end
    end
    
    return modules
end

local upgradeFn = function(_) end

local updateFn = function(params, closureParams)
    params.modelInfo = {}
    for mdl, size in pairs(closureParams.models) do
        params.modelInfo[mdl] = {
            trans = coor.trans(coor.xyz(-size.x, -size.y, 0)),
            size = coor.xyz(size.w, size.h, -size.d),
            fitModels = ust.fitModel(size.w, size.h, size.d, size.t, size.l),
            mdl = mdl
        }
    end
    
    local result = {
        entryConnectors = {},
        colliders = {},
        terrainAlignmentLists = {{type = "EQUAL", faces = {}}},
        groundFaces = {},
        terminalGroups = {},
        stations = {},
        dependentSlots = {},
        edgeLists = {},
        slotConfig = {},
        occupied = {{}, {}, {}, {}},
        cost = 0,
        models = pipe.new * {},
        slots = {},
        labelText = {}
    }
    
    
    params.classedModules = classifyModules(params.modules)
    
    for id, info in pairs(params.classedModules) do
        params.modules[info.slotId].info = ust.slotInfo(info.slotId, params.classedModules)
        params.modules[info.slotId].makeData = function(type, data)
            return ust.mixData(ust.base(id, type), data)
        end
        for id, slotId in pairs(info.slot) do
            params.modules[slotId].info = ust.slotInfo(slotId, params.classedModules)
        end
    end
    
    local grid = gridization(params.modules, params.classedModules)
    params.grid = grid
    params.slotGrid = {}
    
    params.anyRadiusModifiable = false
    for _, module in pairs(params.modules) do
        params.anyRadiusModifiable = params.anyRadiusModifiable or module.info.canModifyRadius or module.info.canModifyDest
    end
    
    for slotId, module in pairs(params.modules) do
        if module.metadata.isTrack then
            local baseTransf =
                quat.byVec(coor.xyz(0, module.info.pos.y < 0 and -1 or 1, 0), module.info.gravity[2]):mRot() *
                coor.trans(module.info.gravity[1])
            
            insert(result.slots, {
                id = slotId,
                transf = baseTransf,
                type = "ust_track",
                spacing = {2.5, 2.5, 2.5, 2.5}
            })
        elseif module.metadata.isPlatform then
            local pos = module.info.pos
            local left = grid[pos.z][pos.x - 1] and grid[pos.z][pos.x - 1][pos.y] and params.modules[grid[pos.z][pos.x - 1][pos.y]]
            local right = grid[pos.z][pos.x + 1] and grid[pos.z][pos.x + 1][pos.y] and params.modules[grid[pos.z][pos.x + 1][pos.y]]
            -- local baseTransf = nil
            -- if left and right then
            --     local pt = left.info.gravity[1]:avg(right.info.gravity[1])
            --     local vec = (left.info.gravity[1] - right.info.gravity[1]):normalized()
            --     baseTransf =
            --         quat.byVec(coor.xyz(0, module.info.pos.y < 0 and -1 or 1, 0), vec):mRot() *
            --         coor.trans(pt)
            -- elseif left then
            --     local pt = left.info.gravity[1] +
            --     local vec = (left.info.gravity[1] - right.info.gravity[1]):normalized()
            --     elseif right then
            --     else
            --         end
            insert(result.slots, {
                id = slotId,
                transf = coor.I(),
                type = "ust_platform",
                spacing = {2.5, 2.5, 2.5, 2.5}
            })
        elseif module.metadata.isData then
            insert(result.slots, {
                id = slotId,
                transf = coor.I(),
                type = "ust_data",
                spacing = {0, 0, 0, 0}
            })
        end
    end
    
    
    for z, gridx in pairs(grid) do
        for x, gridy in pairs(gridx) do
            local ys = func.keys(gridy)
            local min = func.min(ys)
            local max = func.max(ys)
        end
    end
    
    
    
    
    result.terminateConstructionHook = function()
        for _, z in pairs(params.slotGrid) do
            for _, x in pairs(z) do
                for _, y in pairs(x) do
                    for _, s in pairs(y) do
                        insert(result.slots, s)
                    end
                end
            end
        end
    end
    return result
end

function data()
    
    return {
        type = "RAIL_STATION",
        description = {
            name = _("MENU_NAME"),
            description = _("MENU_NAME")
        },
        availability = {
            yearFrom = 0,
            yearTo = 0
        },
        order = 1000,
        constructionTemplates = constructionTemplates,
        createTemplateFn = createTemplateFn,
        params = {
        },
        upgradeFn = upgradeFn,
        updateFn = updateFn,
        preProcessFn = preProcessFn
    }
end
