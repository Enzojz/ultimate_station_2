local func = require "ust/func"
local coor = require "ust/coor"
local pipe = require "ust/pipe"
local ust = require "ust"
local general = require "ust/general"
local quat = require "ust/quaternion"
-- local dump = require "luadump"
local livetext = require "ust/livetext"


local unpack = table.unpack
local insert = table.insert
local ma = math
local pi = ma.pi
local abs = ma.abs
local pow = ma.pow

local updateFn = function(result, transform, tag, slotId, addModelFn, params, closureParams)
    local trackType = closureParams.trackType
    local catenary = closureParams.catenary
    
    local info = params.modules[slotId].info
    local makeData = params.modules[slotId].makeData
    
    local zOffset = params.modules[slotId].metadata.height - params.lowestHeight

    local pos = {0, 0.1, 0.4, 0.5, 0.6, 0.9, 1}
    local e = pipe.new
        * {{2, 1}, {3, 2}, {4, 3}, {4, 5}, {5, 6}, {6, 7}}
        * (info.pos.y < 0 and pipe.noop() or pipe.rev())
        * pipe.map(function(idx)
            local inf = info.arcs.center.inf * (1 - pos[idx[1]]) + info.arcs.center.sup * pos[idx[1]]
            local sup = info.arcs.center.inf * (1 - pos[idx[2]]) + info.arcs.center.sup * pos[idx[2]]
            local length = (pos[idx[2]] - pos[idx[1]]) * info.length
            return {
                {
                    info.arcs.center:pt(inf) + coor.xyz(0, 0, zOffset),
                    info.arcs.center:tangent(inf) * length
                },
                {
                    info.arcs.center:pt(sup) + coor.xyz(0, 0, zOffset),
                    info.arcs.center:tangent(sup) * length
                }
            }
        end)
    
    -- if params.debug then
    --     local nodeCount = #func.mapFlatten(result.edgeLists, function(e) return e.edges end)
    --     for n, nodes in ipairs(e) do
    --         local text1 = tostring(nodeCount + n * 2 - 1)
    --         local text2 = tostring(nodeCount + n * 2)
    --         local addText = function(label, pos, fAlign, h)
    --             local nameModelsF, width = livetext(h or 2)(label)
    --             for _, m in ipairs(nameModelsF(function() return coor.trans(fAlign(width)) * coor.rotX(-0.5 * pi) * coor.trans(pos + coor.xyz(0, 0, 3)) end)) do
    --                 table.insert(result.models, m)
    --             end
    --         end
            
    --         addText(text1, nodes[1][1], function(w) return coor.xyz(-1.5 * w, 0, 0) end, 0.5)
    --         addText(text2, nodes[2][1], function(w) return coor.xyz(0.5 * w, 0, 0) end, 0.5)
    --     end
    -- end

    local edges = {
        type = "TRACK",
        alignTerrain = true,
        params = {
            type = trackType,
            catenary = catenary,
        },
        edges = e * pipe.flatten() * pipe.map(pipe.map(coor.vec2Tuple)),
        snapNodes = func.filter({ (not info.octa[1]) and 1, (not info.octa[5]) and 11 }, pipe.noop()),
        freeNodes = {},
        tag2nodes = {
            [tag] = func.seq(0, 11)
        },
        slot = slotId
    }
    
    table.insert(result.edgeLists, edges)
    
    if info.trackGroup then
        local nodes = func.mapFlatten(result.edgeLists, function(e) return e.edges end)
        params.edgeGroup[slotId] = func.seq(#nodes - 12, #nodes - 1)
    end
    
    local arcs = info.arcs
    local transfPosC = info.transf
    
    if not params.anyRadiusModifiable then
        table.insert(result.slots, {
            id = makeData(80, 0),
            transf = transfPosC,
            type = "ust_modifier",
            spacing = {0, 0, 0, 0}
        })
    end
    
    if (info.id ~= 1) then
        insert(result.slots, {
            id = makeData(99, 0),
            transf = transfPosC,
            type = "ust_remove",
            spacing = {0, 0, 0, 0}
        })
    end
    
    local pos = info.pos
    local metadata = params.modules[slotId].metadata
    local refArc = arcs.center
    
    ust.initSlotGrid(params, pos)
    local newTopologySlots = ust.newTopologySlots(params, makeData, pos)
    
    table.insert(
        result.slots,
        {
            id = makeData(1, 9),
            transf = transfPosC,
            type = "ust_track",
            spacing = {0, 0, 0, 0}
        }
    )

    if not (info.octa[3]) then
        local transf = coor.trans(coor.xyz(metadata.width, 0, 0)) * transfPosC
        newTopologySlots(pos.x + 1, pos.y, transf, 3)
    end
    
    if not (info.octa[7]) then
        local transf = coor.trans(coor.xyz(-metadata.width, 0, 0)) * transfPosC
        newTopologySlots(pos.x - 1, pos.y, transf, 7)
    end
    
    if not ((pos.y < 0 and info.octa[5]) or (pos.y > 0 and info.octa[1])) then
        local fwPt = refArc.sup + 0.5 * (refArc.sup - refArc.inf)
        local transf = quat.byVec(coor.xyz(0, 1, 0), refArc:tangent(fwPt)):mRot() * coor.trans(refArc:pt(fwPt))
        newTopologySlots(pos.x, pos.y + 1, transf, 1)
    end
    
    if not ((pos.y < 0 and info.octa[1]) or (pos.y > 0 and info.octa[5])) then
        local bwPt = refArc.inf - 0.5 * (refArc.sup - refArc.inf)
        local transf = quat.byVec(coor.xyz(0, -1, 0), refArc:tangent(bwPt)):mRot() * coor.trans(refArc:pt(bwPt))
        newTopologySlots(pos.x, pos.y - 1, transf, 5)
    end


    if params.debug then
        local text = tostring(info.id)
        local pos = string.format("(%d, %d)", info.pos.x, info.pos.y)
        
        local addText = function(label, pos, fAlign, h)
            local nameModelsF, width = livetext(h or 2)(label)
            for _, m in ipairs(nameModelsF(function() return coor.trans(fAlign(width)) * coor.rotX(-0.5 * pi) * quat.byVec(coor.xyz(0, info.pos.y < 0 and -1 or 1, 0), info.gravity[2]):mRot() * coor.trans(pos + coor.xyz(0, 0, 3)) end)) do
                table.insert(result.models, m)
            end
        end
        
        addText(text, info.gravity[1], function(w) return coor.xyz(-0.5 * w, 0, 0) end)
        addText(pos, info.gravity[1], function(w) return coor.xyz(-0.5 * w, 0, -2) end, 0.75)
    end

end
function data()
    return {
        updateFn = updateFn,
        getModelsFn = function(params)
            return {}
        end
    }

end
