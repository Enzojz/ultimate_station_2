local ust = require "ust"
local func = require "ust/func"
local pipe = require "ust/pipe"
local quat = require "ust/quaternion"
local coor = require "ust/coor"
local line = require "ust/coorline"
local insert = table.insert
local dump = require "luadump"

local addSlot = function(params, result)
    for id, info in pairs(params.classedModules) do
        local module = params.modules[info.slotId]
        if (module.metadata and module.metadata.isPlatform) then
            local info = module.info
            local makeData = module.makeData
            local pos = info.pos
            
            local grid = {}
            for i = -2, 2 do
                grid[i] = {}
                for j = -2, 2 do
                    local posG = coor.xyz(i, j, 0) + pos
                    local m = params.grid[pos.z][posG.x] and params.grid[pos.z][posG.x][posG.y] and params.modules[params.grid[pos.z][posG.x][posG.y]]
                    if m then
                        grid[i][j] = m
                    end
                end
            end

            local lrData = {
                {
                    fnArc = function(arcs) return arcs.left end,
                    pos = {sup = 8, mid = 7, inf = 6}
                },
                {
                    fnArc = function(arcs) return arcs.right end,
                    pos = {sup = 2, mid = 3, inf = 4}
                }
            }
            
            for _, d in ipairs(lrData) do
                local arc = d.fnArc(info.arcs)
                local pts = {
                    {arc:pt(arc.sup), d.pos.sup},
                    {arc:pt((arc.sup + arc.inf) * 0.5), d.pos.mid},
                    {arc:pt(arc.inf), d.pos.inf},
                }
                for _, ptId in ipairs(pts) do
                    local pt, octapos = table.unpack(ptId)
                    local vec = (info.arcs.left:ptByPt(pt) - info.arcs.right:ptByPt(pt)):normalized()
                    local vecSup = (vec .. coor.rotZ(-0.5 * math.pi)) * 10
                    local vecInf = -vecSup
                    local lnSup = line.byVecPt(vec, pt + vecSup)
                    local lnInf = line.byVecPt(vec, pt + vecInf)
                    local xInfo = {
                        sup = nil,
                        inf = nil
                    }
                    for y = -2, 2 do
                        local m = grid[0][y]
                        if (m and m.metadata.isPlatform) then
                            local arc = d.fnArc(m.info.arcs)
                            
                            if not xInfo.sup then
                                local x = func.filter(arc:xLine(lnSup, true), pipe.noop())
                                if #x == 1 then
                                    local pt = table.unpack(x)
                                    xInfo.sup = {
                                        y = y,
                                        rad = arc:rad(pt),
                                        pt = pt,
                                        arc = arc
                                    }
                                end
                            end
                            if not xInfo.inf then
                                local x = func.filter(arc:xLine(lnInf, true), pipe.noop())
                                if #x == 1 then
                                    local pt = table.unpack(x)
                                    xInfo.inf = {
                                        y = y,
                                        rad = arc:rad(pt),
                                        pt = pt,
                                        arc = arc
                                    }
                                end
                            end
                        else
                            if (xInfo.sup and not xInfo.inf) or (xInfo.inf and not xInfo.sup) then
                                break
                            end
                        end
                        if xInfo.sup and xInfo.inf then break end
                    end
                    if xInfo.sup and xInfo.inf then
                        params.extra[makeData(32, octapos)] = {
                            seq = func.seq(xInfo.inf.y, xInfo.sup.y),
                            slotIds = func.map(func.seq(xInfo.inf.y, xInfo.sup.y), function(y) return grid[0][y].info.slotId end),
                            arcs = func.map(func.seq(xInfo.inf.y, xInfo.sup.y), function(y) return d.fnArc(grid[0][y].info.arcs) end),
                            vecNormal = octapos > 5 and vec or -vec,
                            xInfo = xInfo,
                            lnSup = lnSup,
                            lnInf = lnInf
                        }
                        insert(
                            result.slots, {
                                id = makeData(32, octapos),
                                transf = quat.byVec(coor.xyz(0, -1, 0), octapos > 5 and vec or -vec):mRot() * coor.trans((xInfo.sup.pt + xInfo.inf.pt) * 0.5),
                                type = "ust_component_main_20",
                                spacing = {10, 10, 1, 1}
                            })
                    end
                end
            end
        end
    end

end

function data()
    return {
        classify = ust.classifyComp,
        addSlot = addSlot
    }

end
