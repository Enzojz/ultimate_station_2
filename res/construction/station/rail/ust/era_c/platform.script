local func = require "ust/func"
local coor = require "ust/coor"
local quat = require "ust/quaternion"
local ust = require "ust"
local dump = require "luadump"

local insert = table.insert
local math = math
local abs = math.abs
local floor = math.floor

local preProcessAdd = function(modules, change, classedModules, info)
    local maxId = func.max(func.keys(classedModules))
    
    local grid = {}
    for id, info in pairs(classedModules) do
        local pos = modules[info.slotId].info.pos
        local x, y, z = pos.x, pos.y, pos.z
        if not grid[z] then grid[z] = {} end
        if not grid[z][x] then grid[z][x] = {} end
        grid[z][x][y] = info.slotId
    end
    
    
    if (info.data == -1) then
        local id = info.id
        local slotId = classedModules[id].slotId
        modules[slotId].name = change.module.name
    else
        local refPos = modules[classedModules[info.id].slotId].info.pos
        
        local pos = ({
            [1] = coor.xyz(0, 1, 0),
            [3] = coor.xyz(1, 0, 0),
            [5] = coor.xyz(0, -1, 0),
            [7] = coor.xyz(-1, 0, 0)
        })[info.data] + refPos
        
        
        local x, y, z = pos.x, pos.y, pos.z
        
        local octa = {
            [5] = grid[z][x] and grid[z][x][y - 1] or nil,
            [1] = grid[z][x] and grid[z][x][y + 1] or nil,
            [7] = grid[z][x - 1] and grid[z][x - 1][y] or nil,
            [3] = grid[z][x + 1] and grid[z][x + 1][y] or nil,
            [6] = grid[z][x - 1] and grid[z][x - 1][y - 1] or nil,
            [4] = grid[z][x + 1] and grid[z][x + 1][y - 1] or nil,
            [8] = grid[z][x - 1] and grid[z][x - 1][y + 1] or nil,
            [2] = grid[z][x + 1] and grid[z][x + 1][y + 1] or nil,
        }
        
        local function isTrack(pos)
            return octa[pos] and modules[octa[pos]].metadata.isTrack
        end
        
        local function isPlatform(pos)
            return octa[pos] and modules[octa[pos]].metadata.isPlatform
        end
        
        local function isEmpty(pos)
            return not octa[pos] and not modules[octa[pos]]
        end
        
        local ref = {}
        if isTrack(3) and isTrack(7) then
            ref = {left = true, right = true}
        elseif isTrack(7) and not isPlatform(3) then
            ref = {left = true}
        elseif isTrack(3) and not isPlatform(7) then
            ref = {right = true}
        
        elseif isPlatform(7) and isPlatform(3) then
            ref = {left = true, right = true}
        elseif isPlatform(7) then
            ref = {left = true}
        elseif isPlatform(3) then
            ref = {right = true}

        elseif isPlatform(1) and isPlatform(5) then
            ref = {prev = true}
        elseif isPlatform(1) then
            ref = {next = true}
        elseif isPlatform(5) then
            ref = {prev = true}
                
        elseif isEmpty(3) and isEmpty(7) and not isEmpty(1) and not isEmpty(5) then
            ref = {prev = true}
        elseif isEmpty(3) and isEmpty(7) and not isEmpty(5) then
            ref = {prev = true}
        elseif isEmpty(3) and isEmpty(7) and not isEmpty(1) then
            ref = {next = true}
        end
        
        local newInfo = {
            id = maxId + 1,
            type = change.module.metadata.typeId,
            pos = pos,
            length = 20,
            width = 5,
            ref = ref
        }
        local slotId, dataIds = ust.slotIds(newInfo)
        
        modules[slotId] = change.module
        
        for m, slotIds in pairs(dataIds) do
            for _, slotId in ipairs(slotIds) do
                modules[slotId] = {
                    metadata = {isData = true},
                    name = string.format("station/rail/ust/%s.module", m),
                    updateScript = {
                        fileName = "",
                        params = {}
                    },
                    variant = 0
                }
            
            end
        end
    end
end

local slotSetup = function(params, result, slotId)
    local module = params.modules[slotId]
    local info = params.modules[slotId].info
    local makeData = params.modules[slotId].makeData
    local pos = info.pos
    local metadata = params.modules[slotId].metadata
    local transfPosC = info.transf
    
    insert(result.slots, {
        id = slotId,
        transf = module.info.transf,
        type = module.metadata.typeName,
        spacing = {0, 0, 0, 0}
    })
    
    if (info.id ~= 1) then
        insert(result.slots, {
            id = makeData(2, -2),
            transf = transfPosC,
            type = "ust_remove",
            spacing = {0, 0, 0, 0}
        })
    end
    
    -- SLot to replace itself
    insert(
        result.slots,
        {
            id = makeData(2, -1),
            transf = transfPosC,
            type = "ust_platform",
            spacing = {0, 0, 0, 0}
        }
    )
    
    ust.initSlotGrid(params, pos)
    local newTopologySlots = ust.newTopologySlots(params, makeData, pos)
    
    if not (info.octa[3]) then
        local transf = ust.getTranfs(info, 3, metadata.width)
        newTopologySlots(pos.x + 1, pos.y, transf, 3)
    end
    
    if not (info.octa[7]) then
        local transf = ust.getTranfs(info, 7, metadata.width)
        newTopologySlots(pos.x - 1, pos.y, transf, 7)
    end
    
    if not info.octa[1] then
        local transf = ust.getTranfs(info, 1, metadata.width)
        newTopologySlots(pos.x, pos.y + 1, transf, 1)
    end
    
    if not info.octa[5] then
        local transf = ust.getTranfs(info, 5, metadata.width)
        newTopologySlots(pos.x, pos.y - 1, transf, 5)
    end
end

local preProcessRemove = function(modules, change, classedModules, info)
    for _, slotId in pairs(classedModules[info.id].slot) do
        modules[slotId] = nil
    end
    modules[change.slotId] = nil
end

function data()
    return {
        preClassify = ust.preClassify,
        preProcessAdd = preProcessAdd,
        preProcessRemove = preProcessRemove,
        slotSetup = slotSetup
    }

end
