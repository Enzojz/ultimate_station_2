local coor = require "ust/coor"
local quat = require "ust/quaternion"
local livetext = require "ust/livetext"
local ust = require "ust"
local dump = require "luadump"

local unpack = table.unpack
local insert = table.insert
local ma = math
local pi = ma.pi

local mark = function(result, slotId, params)
    local id = params.modules[slotId].info.id
    local sId = params.classedModules[id].slotId
    local info = params.modules[sId].info
    local makeData = params.modules[sId].makeData
    
    local hRef = params.platformHeight
    local hVec = coor.xyz(0, 0, hRef)
    local hTrans = coor.trans(hVec)
    
    local n = 10
    local ptsL, vecL = ust.basePts(info.arcs.left, n)
    local ptsR, vecR = ust.basePts(info.arcs.right, n)
    local ptsC, vecC = ust.basePts(info.arcs.center, n)
    
    local addText = function(label, transf, f)
        local nameModelsF, width = livetext(2)(label)
        for _, m in ipairs(nameModelsF(function() return (f or coor.I()) * coor.transZ(-0.85) * coor.rotX(-0.5 * pi) * hTrans * transf end)) do
            table.insert(result.models, m)
        end
    end

    for _, pt in ipairs(ptsL) do
        addText("⋮", coor.trans(pt), coor.transX(-0.1))
    end
    
    for _, pt in ipairs(ptsR) do
        addText("⋮", coor.trans(pt), coor.transX(-0.1))
    end
    
    for _, pt in ipairs({ptsL[1], ptsL[11], ptsR[1], ptsR[11], ptsC[1], ptsC[11]}) do
        addText("⋯", coor.trans(pt), coor.transX(-0.5))
    end

    if info.ref.left then
        local refPt = ptsL[6]
        local refVec = vecL[6]
        local transf = quat.byVec(coor.xyz(0, info.pos.y < 0 and -1 or 1, 0), refVec):mRot() * coor.trans(refPt)
        addText("⋘", transf, coor.transX(0.2))
    end
    
    if info.ref.right then
        local refPt = ptsR[6]
        local refVec = vecR[6]
        local transf = quat.byVec(coor.xyz(0, info.pos.y < 0 and 1 or -1, 0), refVec):mRot() * coor.trans(refPt)
        addText("⋘", transf, coor.transX(0.2))
    end
    
    if info.ref.next then
        local i = info.pos.y < 0 and 1 or 11
        local refPt = ptsC[i]
        local refVec = vecC[i]
        local transf = quat.byVec(coor.xyz(info.pos.y < 0 and 1 or -1, 0, 0), refVec):mRot() * coor.trans(refPt)
        addText("⋘", transf, coor.transX(0.2))
    end
    
    if info.ref.prev then
        local i = info.pos.y < 0 and 11 or 1
        local refPt = ptsC[i]
        local refVec = vecC[i]
        local transf = quat.byVec(coor.xyz(info.pos.y < 0 and -1 or 1, 0, 0), refVec):mRot() * coor.trans(refPt)
        addText("⋘", transf, coor.transX(0.2))
    end
end

local updateFn = function(result, transform, tag, slotId, addModelFn, params)
    local id = params.modules[slotId].info.id
    local sId = params.classedModules[id].slotId
    local info = params.modules[sId].info
    local makeData = params.modules[sId].makeData
    
    insert(result.slots, {
        id = makeData(90, 1),
        transf = info.transf,
        type = "ust_ref_modifier",
        spacing = {0, 0, 0, 0}
    })
    
    local n = 2
    local ptsL, vecL = ust.basePts(info.arcs.left, n)
    local ptsR, vecR = ust.basePts(info.arcs.right, n)
    local ptsC, vecC = ust.basePts(info.arcs.center, n)
    
    local addSlot = function(cond, data, transf)
        if cond then
            table.insert(result.slots, {
                id = makeData(91, data),
                transf = coor.scale(coor.xyz(0.125, 0.5, 1)) * coor.rotZ(-0.25 * pi) * transf,
                type = "ust_ref_modifier",
                spacing = {0, 0, 0, 0},
                shape = 2
            })
            
            table.insert(result.slots, {
                id = makeData(91, data),
                transf = coor.scale(coor.xyz(0.125, 0.5, 1)) * coor.rotZ(0.25 * pi) * transf,
                type = "ust_ref_modifier",
                spacing = {0, 0, 0, 0},
                shape = 2
            })
        else
            table.insert(result.slots, {
                id = makeData(91, data),
                transf = transf,
                type = "ust_ref_modifier",
                spacing = {0, 0, 0, 0},
                shape = 1
            })
        end
    end
    mark(result, slotId, params)
    
    for _, octa in ipairs(info.octa) do
        if octa then
            mark(result, octa, params)
        end
    end

    do
        local refPt = ptsL[2]
        local refVec = vecL[2]
        local transf = quat.byVec(coor.xyz(0, info.pos.y < 0 and -1 or 1, 0), refVec):mRot() * coor.trans(refPt)
        
        if info.octa[7] and params.modules[info.octa[7]] and not params.modules[info.octa[7]].info.ref.right then
            local sum = (info.ref.right and 2 or 0) + (info.ref.left and 0 or 1)
            if (sum ~= 0) then
                addSlot(info.ref.left, sum, transf)
            end
        end
    end
    
    do
        local refPt = ptsR[2]
        local refVec = vecR[2]
        local transf = quat.byVec(coor.xyz(0, info.pos.y < 0 and 1 or -1, 0), refVec):mRot() * coor.trans(refPt)
        
        if info.octa[3] and params.modules[info.octa[3]] and not params.modules[info.octa[3]].info.ref.left then
            local sum = (info.ref.left and 1 or 0) + (info.ref.right and 0 or 2)
            if sum ~= 0 then
                addSlot(info.ref.right, sum, transf)
            end
        end
    end
    
    do
        local i = info.pos.y < 0 and 1 or 3
        local refPt = ptsC[i]
        local refVec = vecC[i]
        local transf = quat.byVec(coor.xyz(info.pos.y < 0 and 1 or -1, 0, 0), refVec):mRot() * coor.trans(refPt)
        
        if info.octa[1] and params.modules[info.octa[1]] and not params.modules[info.octa[1]].info.ref.prev then
            if not info.ref.next then
                addSlot(info.ref.next, 4, transf)
            end
        end
        
    end
    
    do
        local i = info.pos.y < 0 and 3 or 1
        local refPt = ptsC[i]
        local refVec = vecC[i]
        local transf = quat.byVec(coor.xyz(info.pos.y < 0 and -1 or 1, 0, 0), refVec):mRot() * coor.trans(refPt)
        
        if info.octa[5] and params.modules[info.octa[5]] and not params.modules[info.octa[5]].info.ref.next then
            if not info.ref.prev then
                addSlot(info.ref.prev, 8, transf)
            end
        end
    end
end

function data()
    return {
        availability = {
            yearFrom = 0,
            yearTo = 0,
        },
        visible = false,
        buildMode = "SINGLE",
        cost = {
            price = 0,
        },
        description = {
            name = _("MENU_REF_MODIFIER"),
            description = _("MENU_REF_MODIFIER_DESC"),
        },
        category = {
            categories = {"modifiers"},
        },
        type = "ust_ref_modifier",
        order = {
            value = 260,
        },
        metadata = {
            typeName = "ust_ref_modifier",
            isData = true,
            type = 2,
            scriptName = "construction/station/rail/ust/ref_modifier",
            preProcessAdd = "preProcessAdd",
            preProcessPostAdd = "preProcessPostAdd",
            classify = "classify"
        },
        
        updateFn = updateFn,
        
        getModelsFn = function(params)
            return {}
        end
    }

end
