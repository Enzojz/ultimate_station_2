local func = require "ust/func"
local coor = require "ust/coor"
local pipe = require "ust/pipe"
local ust = require "ust"
local general = require "ust/general"
local quat = require "ust/quaternion"
local dump = require "luadump"
local livetext = require "ust/livetext"


local unpack = table.unpack
local ma = math
local pi = ma.pi

local fitModels = {
    surface = ust.fitModel(3.4, 5, -1.93, true, true),
    extremity = ust.fitModel(3.4, 5, -1.93, true, true),
    edge = ust.fitModel(0.8, 5, -1.93, true, true),
    cornerLeft = ust.fitModel(0.8, 5, -1.93, true, true),
    cornerRight = ust.fitModel(0.8, 5, -1.93, true, false),
}

local updateFn = function(result, transform, tag, slotId, addModelFn, params)
    local info = params.modules[slotId].info
    local makeData = params.modules[slotId].makeData
    
    local pts = info.pts
    
    local e = {{}, {}}
    
    if (info.pos.y > 0) then
        e = {
            info.prev and {
                pts[1][1]:avg(params.modules[info.prev].info.pts[2][1]),
                pts[1][2]:avg(params.modules[info.prev].info.pts[2][2])
            } or pts[1],
            
            info.next and {
                pts[2][1]:avg(params.modules[info.next].info.pts[1][1]),
                pts[2][2]:avg(params.modules[info.next].info.pts[1][2])
            } or pts[2]
        }
    elseif (info.pos.y == 0) then
        e = {
            info.prev and {
                pts[1][1]:avg(params.modules[info.prev].info.pts[1][1]),
                pts[1][2]:avg(-params.modules[info.prev].info.pts[1][2])
            } or pts[1],
            
            info.next and {
                pts[2][1]:avg(params.modules[info.next].info.pts[1][1]),
                pts[2][2]:avg(params.modules[info.next].info.pts[1][2])
            } or pts[2]
        }
    elseif (info.pos.y == -1) then
        e = {
            info.next and {
                pts[1][1]:avg(params.modules[info.next].info.pts[1][1]),
                pts[1][2]:avg(-params.modules[info.next].info.pts[1][2])
            } or pts[1],
            
            info.prev and {
                pts[2][1]:avg(params.modules[info.prev].info.pts[1][1]),
                pts[2][2]:avg(params.modules[info.prev].info.pts[1][2])
            } or pts[2],
        
        }
    else
        e = {
            info.next and {
                pts[1][1]:avg(params.modules[info.next].info.pts[2][1]),
                pts[1][2]:avg(params.modules[info.next].info.pts[2][2])
            } or pts[1],
            
            info.prev and {
                pts[2][1]:avg(params.modules[info.prev].info.pts[1][1]),
                pts[2][2]:avg(params.modules[info.prev].info.pts[1][2])
            } or pts[2],
        
        }
    end
    
    local e = pipe.new * e * pipe.map(function(e) return {e[1], e[2] * info.length} end) * pipe.map(pipe.map(coor.vec2Tuple))
    
    local edges = {
        type = "TRACK",
        alignTerrain = true,
        params = {
            type = "standard.lua",
            catenary = false,
        },
        edges = e,
        snapNodes = {},
        freeNodes = {},
        tag2nodes = {
            [tag] = func.seq(0, #e - 1)
        },
        slot = slotId
    }
    
    table.insert(result.edgeLists, edges)
    
    if info.canModifyRadius then
        local arcs = info.arcs
        local step = (arcs.center.sup - arcs.center.inf) / 7
        
        for i = 0, 6 do
            local rad = arcs.center.inf + step * (i + 1)
            local posL, posR = arcs.left:pt(rad), arcs.right:pt(rad)
            local vec = (posR - posL):normalized()
            local posC = (posR + posL) * 0.5
            local posP = posL - vec
            local posN = posR + vec
            local rotZ = quat.byVec(coor.xyz(1, 0, 0), vec):mRot()
            local textR = info.radius == 10e8 and "R∞" or string.format("R%d", math.abs(info.radius))
            
            local addText = function(label, pos, fAlign, h)
                local nameModelsF, width = livetext(h or 2)(label)
                for _, m in ipairs(nameModelsF(function() return coor.trans(fAlign(width)) * coor.rotX(-0.5 * math.pi) * rotZ * coor.trans(pos + coor.xyz(0, 0, 3)) end)) do
                    table.insert(result.models, m)
                end
            end
            
            local addSlot = function(id, data, pos, shape, rot)
                table.insert(result.slots, {
                    id = makeData(id, data),
                    transf = coor.scale(coor.xyz(0.75, 0.75, 0.75)) * (rot or rotZ) * coor.trans(pos) * coor.transZ(1),
                    type = "ust_modifier",
                    spacing = {1, 1, 1, 1},
                    shape = shape or 0
                })
            end
            
            local var = params.modules[params.classedModules[info.id].slot[80]].variant
            
            if (i == 0) then
                addText(textR, posC, function(w) return coor.xyz(-0.5 * w, 0, -1) end)
                addSlot(83 + var, 0, posP)
                addText("−", posP, function(w) return coor.xyz(-w - 2, 0, -1) end)
                if (params.classedModules[info.id].slot[54] or params.classedModules[info.id].slot[55] or params.classedModules[info.id].slot[56]) then
                    addSlot(83 + var, 1, posN)
                    addText("∗", posN, function(w) return coor.xyz(2, 0, -1) end)
                end
            elseif i == 6 then
                addText(textR, posC, function(w) return coor.xyz(-0.5 * w, 0, -1) end)
            else
                if (info.radius > 0 or info.radius + math.pow(10, i - 1) < 0) then
                    addSlot(81 + var, i, posP, 1)
                end
                if (info.radius < 0 or info.radius - math.pow(10, i - 1) > 0) then
                    addSlot(81 + var, -i, posN, 1, quat.byVec(coor.xyz(-1, 0, 0), vec):mRot())
                end
                addText(string.format("∙ %d ∙", math.pow(10, i - 2)), posC, function(w) return coor.xyz(-w * 0.5, 0, -0.75) end, 1.5)
            end
        end
    end

end
function data()
    return {
        availability = {
            yearFrom = 0,
            yearTo = 0,
        },
        buildMode = "SINGLE",
        cost = {
            price = 0,
        },
        description = {
            name = _("MENU_MODULE_PLATFORM"),
            description = _("MENU_MODULE_PLATFORM_DESC"),
        },
        category = {
            categories = {"tracks"},
        },
        type = "ust_track",
        order = {
            value = 260,
        },
        metadata = {
            isTrack = true,
            typeId = 1,
            width = 5
        },
        
        updateFn = updateFn,
        
        getModelsFn = function(params)
            return {}
        end
    }

end
