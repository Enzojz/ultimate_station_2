local func = require "ust/func"
local coor = require "ust/coor"
local pipe = require "ust/pipe"
local ust = require "ust"
local general = require "ust/general"
local quat = require "ust/quaternion"
local dump = require "luadump"
local livetext = require "ust/livetext"


local unpack = table.unpack
local insert = table.insert
local ma = math
local pi = ma.pi
local abs = ma.abs
local pow = ma.pow

local fitModels = {
    surface = ust.fitModel(3.4, 5, -1.93, true, true),
    extremity = ust.fitModel(3.4, 5, -1.93, true, true),
    edge = ust.fitModel(0.8, 5, -1.93, true, true),
    cornerLeft = ust.fitModel(0.8, 5, -1.93, true, true),
    cornerRight = ust.fitModel(0.8, 5, -1.93, true, false),
}

local updateFn = function(result, transform, tag, slotId, addModelFn, params)
    local info = params.modules[slotId].info
    local makeData = params.modules[slotId].makeData
    
    local pts = info.pts
    
    local e = {{}, {}}
    
    if (info.pos.y > 0) then
        e = {
            info.prev and {
                pts[1][1]:avg(params.modules[info.prev].info.pts[2][1]),
                pts[1][2]:avg(params.modules[info.prev].info.pts[2][2])
            } or pts[1],
            
            info.next and {
                pts[2][1]:avg(params.modules[info.next].info.pts[1][1]),
                pts[2][2]:avg(params.modules[info.next].info.pts[1][2])
            } or pts[2]
        }
    elseif (info.pos.y == 0) then
        e = {
            info.prev and {
                pts[1][1]:avg(params.modules[info.prev].info.pts[1][1]),
                pts[1][2]:avg(-params.modules[info.prev].info.pts[1][2])
            } or pts[1],
            
            info.next and {
                pts[2][1]:avg(params.modules[info.next].info.pts[1][1]),
                pts[2][2]:avg(params.modules[info.next].info.pts[1][2])
            } or pts[2]
        }
    elseif (info.pos.y == -1) then
        e = {
            info.next and {
                pts[1][1]:avg(params.modules[info.next].info.pts[1][1]),
                pts[1][2]:avg(-params.modules[info.next].info.pts[1][2])
            } or pts[1],
            
            info.prev and {
                pts[2][1]:avg(params.modules[info.prev].info.pts[1][1]),
                pts[2][2]:avg(params.modules[info.prev].info.pts[1][2])
            } or pts[2],
        
        }
    else
        e = {
            info.next and {
                pts[1][1]:avg(params.modules[info.next].info.pts[2][1]),
                pts[1][2]:avg(params.modules[info.next].info.pts[2][2])
            } or pts[1],
            
            info.prev and {
                pts[2][1]:avg(params.modules[info.prev].info.pts[1][1]),
                pts[2][2]:avg(params.modules[info.prev].info.pts[1][2])
            } or pts[2],
        
        }
    end
    
    table.insert(result.models, func.with(ust.unitLane(coor.xyz(0, 0, -2) + pts[2][1], coor.xyz(0, 0, -2) + pts[1][1]), {tag = tag}))
    
    local e = pipe.new * e * pipe.map(function(e) return {e[1], e[2] * info.length} end) * pipe.map(pipe.map(coor.vec2Tuple))
    
    local edges = {
        type = "TRACK",
        alignTerrain = true,
        params = {
            type = "standard.lua",
            catenary = false,
        },
        edges = e,
        snapNodes = {},
        freeNodes = {},
        tag2nodes = {
            [tag] = func.seq(0, #e - 1)
        },
        slot = slotId
    }
    
    table.insert(result.edgeLists, edges)
    
    
    -- Entry for radius system
    do
        local arcs = info.arcs
        local rad = (arcs.center.inf + arcs.center.sup) * 0.5
        local posL, posR = arcs.left:pt(rad), arcs.right:pt(rad)
        local vec = (posR - posL):normalized()
        local posC = (posR + posL) * 0.5
        local rotZ = quat.byVec(coor.xyz(1, 0, 0), vec):mRot()
        local transfPosC = rotZ * coor.trans(posC)
        
        if not params.anyRadiusModifiable then
            table.insert(result.slots, {
                id = makeData(80, 0),
                transf = transfPosC * coor.transZ(1),
                type = "ust_modifier",
                spacing = {1.5, 1.5, 1.5, 1.5}
            })
        elseif info.canModifyRadius then
            table.insert(result.slots, {
                id = makeData(80, 1),
                transf = transfPosC * coor.transZ(1),
                type = "ust_modifier",
                spacing = {1.5, 1.5, 1.5, 1.5}
            })
        end
        
        if (info.id ~= 1) then
            insert(result.slots, {
                id = makeData(99, 0),
                transf = transfPosC * coor.transZ(1),
                type = "ust_remove",
                spacing = {1.5, 1.5, 1.5, 1.5}
            })
        end

        -- Radius modify system
        if info.canModifyRadius then
            local step = (arcs.center.sup - arcs.center.inf) / 8
            
            for i = 0, 8 do
                local rad = arcs.center.inf + step * i
                local posL, posR = arcs.left:pt(rad), arcs.right:pt(rad)
                local vec = (posR - posL):normalized()
                local posC = (posR + posL) * 0.5
                local posP = posL - vec
                local posN = posR + vec
                local rotZ = quat.byVec(coor.xyz(1, 0, 0), vec):mRot()
                local textR = info.radius == 10e8 and "R∞" or string.format("R%d(%s)", abs(info.radius), info.radius < 0 and "-" or "+")
                
                local addText = function(label, pos, fAlign, h)
                    local nameModelsF, width = livetext(h or 2)(label)
                    for _, m in ipairs(nameModelsF(function() return coor.trans(fAlign(width)) * coor.rotX(-0.5 * pi) * rotZ * coor.trans(pos + coor.xyz(0, 0, 3)) end)) do
                        table.insert(result.models, m)
                    end
                end
                
                local addSlot = function(id, data, pos, shape, rot)
                    table.insert(result.slots, {
                        id = makeData(id, data),
                        transf = coor.scale(coor.xyz(0.75, 0.75, 0.75)) * (rot or rotZ) * coor.trans(pos) * coor.transZ(1),
                        type = "ust_modifier",
                        spacing = {1, 1, 1, 1},
                        shape = shape or 0
                    })
                end
                
                local var = params.modules[params.classedModules[info.id].slot[80]].variant
                
                if (i == 0) then
                    addText(textR, posC, function(w) return coor.xyz(-0.5 * w, 0, -1) end)
                elseif (i == 1) then
                    addSlot(83 + var, 0, posP)
                    addText("∞ ⊘", posC, function(w) return coor.xyz(-w * 0.5, 0, -1) end)
                    if (params.classedModules[info.id].slot[54] or params.classedModules[info.id].slot[55] or params.classedModules[info.id].slot[56]) then
                        addSlot(83 + var, 1, posN)
                    end
                elseif i == 7 then
                    addText("+", posP, function(w) return coor.xyz(-0.5 * w, 0, -1) end)
                    addText("-", posN, function(w) return coor.xyz(-0.5 * w, 0, -1) end)
                elseif i == 8 then
                    addText(textR, posC, function(w) return coor.xyz(-0.5 * w, 0, -1) end)
                else
                    local delta = pow(10, i - 2)
                    if info.radius == 10e8 or (abs((info.radius or 0) + delta) >= 50 and (info.radius or 0) + delta < 999999) then
                        local dir = (info.radius and info.radius < 999999 and (info.radius > 0 or (info.radius < 0 and info.radius + delta < 0))) and coor.xyz(-1, 0, 0) or coor.xyz(1, 0, 0)
                        addSlot(81 + var, i - 1, posP, 1, quat.byVec(dir, vec):mRot())
                    end
                    if abs((info.radius or 0) - delta) >= 50 and (info.radius or 0) - delta > -999999 then
                        local dir = (info.radius and info.radius < 999999 and (info.radius < 0 or (info.radius > 0 and info.radius - delta > 0))) and coor.xyz(1, 0, 0) or coor.xyz(-1, 0, 0)
                        addSlot(81 + var, -i + 1, posN, 1, quat.byVec(dir, vec):mRot())
                    end
                    addText(string.format("∙ %d ∙", delta), posC, function(w) return coor.xyz(-w * 0.5, 0, -0.75) end, 1.5)
                end
            end
        end
        
        local grid = params.grid
        local pos = info.pos
        local metadata = params.modules[slotId].metadata
        local refArc = arcs.center
        
        if not (grid[pos.z][pos.x - 1] and (grid[pos.z][pos.x - 1][pos.y + 1] or grid[pos.z][pos.x - 1][pos.y - 1])) then
            table.insert(result.slots, {
                id = ust.mixData(slotId, 1),
                transf = coor.trans(coor.xyz(-metadata.width, 0, 0)) * transfPosC,
                type = "ust_track",
                spacing = {1.5, 1.5, 1.5, 1.5}
            })
        end
        
        if not (grid[pos.z][pos.x + 1] and (grid[pos.z][pos.x + 1][pos.y + 1] or grid[pos.z][pos.x + 1][pos.y - 1])) then
            table.insert(result.slots, {
                id = ust.mixData(slotId, 2),
                transf = coor.trans(coor.xyz(metadata.width, 0, 0)) * transfPosC,
                type = "ust_track",
                spacing = {1.5, 1.5, 1.5, 1.5}
            })
        end
        
        if not grid[pos.z][pos.x][pos.y + (pos.y < 0 and 1 or -1)] then
            local bwPt = refArc.inf - 0.5 * (refArc.sup - refArc.inf)
            table.insert(result.slots, {
                id = ust.mixData(slotId, 3),
                transf = quat.byVec(coor.xyz(0, -1, 0), refArc:tangent(bwPt)):mRot() * coor.trans(refArc:pt(bwPt)),
                type = "ust_track",
                spacing = {1.5, 1.5, 1.5, 1.5}
            })
        end
        
        if not grid[pos.z][pos.x][pos.y + (pos.y < 0 and -1 or 1)] then
            local fwPt = refArc.sup + 0.5 * (refArc.sup - refArc.inf)
            table.insert(result.slots, {
                id = ust.mixData(slotId, 4),
                transf = quat.byVec(coor.xyz(0, 1, 0), refArc:tangent(fwPt)):mRot() * coor.trans(refArc:pt(fwPt)),
                type = "ust_track",
                spacing = {1.5, 1.5, 1.5, 1.5}
            })
        end
    end

    

end
function data()
    return {
        availability = {
            yearFrom = 0,
            yearTo = 0,
        },
        buildMode = "SINGLE",
        cost = {
            price = 0,
        },
        description = {
            name = _("MENU_MODULE_PLATFORM"),
            description = _("MENU_MODULE_PLATFORM_DESC"),
        },
        category = {
            categories = {"tracks"},
        },
        type = "ust_track",
        order = {
            value = 260,
        },
        metadata = {
            isTrack = true,
            typeId = 1,
            width = 5
        },
        
        updateFn = updateFn,
        
        getModelsFn = function(params)
            return {}
        end
    }

end
