local func = require "ust/func"
local coor = require "ust/coor"
local pipe = require "ust/pipe"
local ust = require "ust"
local quat = require "ust/quaternion"
local dump = require "luadump"
local livetext = require "ust/livetext"

local fitModels = ust.fitModel(1, 1, 1, true, true)

local insert = table.insert
local gap = 0.01
local updateFn = function(result, transform, tag, slotId, addModelFn, params)
    local info = params.modules[slotId].info
    local function setPos()
        if info.trackGroup.right then
            local trackGroup = params.trackGroup[info.trackGroup.right]
            local n = #trackGroup
            hasCenterNode = n % 2 == 1 and (n + 1) / 2 == info.trackGroup.rightPos
            hasInfNode = n % 2 == 0 and (n / 2) == info.trackGroup.rightPos - 1
            hasSupNode = n % 2 == 0 and (n / 2) == info.trackGroup.rightPos
            
            if hasCenterNode then
                local pos = {{0, 0.3}, {0.7, 1}}
                local posCore = {{0.3 + gap, 0.5}, {0.5, 0.7 - gap}}
                local conn = {{0.7 - gap, 0.7}, {0.3 + gap, 0.3}}
                local node = 1
                return {pos, posCore}, conn, node, {0, 1, 2, 3}
            elseif hasInfNode then
                local pos = {{0.2, 1}}
                local posCore = {{0, 0.2 - gap}}
                local conn = {{0.2 - gap, 0.2}}
                local node = 0
                return {pos, posCore}, conn, node, {0, 1}
            elseif hasSupNode then
                local pos = {{0, 0.8}}
                local posCore = {{0.8 + gap, 1}}
                local conn = {{0.8, 0.8 + gap}}
                return {pos, posCore}, conn, nil, {0, 1}
            else
                return {{{0, 1}}}, nil, nil, {0, 1}
            end
        elseif info.trackGroup.left then
            local trackGroup = params.trackGroup[info.trackGroup.left]
            local n = #trackGroup
            hasCenterNode = n % 2 == 1 and (n + 1) / 2 == info.trackGroup.leftPos
            hasInfNode = n % 2 == 0 and (n / 2) == info.trackGroup.leftPos - 1
            hasSupNode = n % 2 == 0 and (n / 2) == info.trackGroup.leftPos
            
            if hasCenterNode then
                local pos = {{1, 0.7}, {0.3, 0}}
                local posCore = {{0.7 - gap, 0.5}, {0.5, 0.3 + gap}}
                local conn = {{0.7 - gap, 0.7}, {0.3 + gap, 0.3}}
                local node = 1
                return {pos, posCore}, conn, node, {3, 2, 1, 0}
            elseif hasSupNode then
                local pos = {{0.8, 0}}
                local posCore = {{1, 0.8 + gap}}
                local conn = {{0.8, 0.8 + gap}}
                local node = 0
                return {pos, posCore}, conn, node, {1, 0}
            elseif hasInfNode then
                local pos = {{1, 0.2}}
                local posCore = {{0.2 - gap, 0}}
                local conn = {{0.2 - gap, 0.2}}
                return {pos, posCore}, conn, nil, {1, 0}
            else
                return {{{1, 0}}}, nil, nil, {1, 0}
            end
        else 
            return {{{0, 1}}}, nil, nil, {0, 1}
        end
    end
    
    local pos, conn, node, seqNodes = setPos()
    
    local e = func.map(pos,
        pipe.map(function(idx)
            local inf = info.arcs.center.inf * (1 - idx[1]) + info.arcs.center.sup * idx[1]
            local sup = info.arcs.center.inf * (1 - idx[2]) + info.arcs.center.sup * idx[2]
            local length = (idx[2] - idx[1]) * info.length
            return {
                {
                    info.arcs.center:pt(inf) + coor.xyz(0, 0, info.height),
                    info.arcs.center:tangent(inf) * length
                },
                {
                    info.arcs.center:pt(sup) + coor.xyz(0, 0, info.height),
                    info.arcs.center:tangent(sup) * length
                }
            }
        end)
    )
    local edges = {
        type = "STREET",
        alignTerrain = true,
        params = {
            type = "ust/brick.lua",
            catenary = false,
            tramTrackType = "YES"
        },
        edges = pipe.new * e[1] * pipe.flatten() * pipe.map(pipe.map(coor.vec2Tuple)),
        snapNodes = func.filter({(not info.octa[1]) and seqNodes[#seqNodes], (not info.octa[5]) and seqNodes[1]}, pipe.noop()),
        freeNodes = {},
        seqNodes = seqNodes,
        tag2nodes = {
            [tag] = seqNodes
        },
        slot = slotId
    }
    
    insert(result.edgeLists, edges)
    
    if e[2] then
        local edgesCore = {
            type = "STREET",
            alignTerrain = true,
            params = {
                type = "ust/brick_core.lua",
                catenary = false,
                tramTrackType = "YES"
            },
            edges = pipe.new * e[2] * pipe.flatten() * pipe.map(pipe.map(coor.vec2Tuple)),
            snapNodes = {},
            freeNodes = {},
            seqNodes = seqNodes,
            tag2nodes = {
                [tag] = seqNodes
            },
            slot = slotId
        }
        
        if node then
            local nodes = func.mapFlatten(result.edgeLists, function(e) return e.edges end)
            result.terminalGroups[info.trackGroup.left or info.trackGroup.right].vehicleNodeOverride = #nodes + node
        end
        insert(result.edgeLists, edgesCore)
        for _, conn in ipairs(conn) do
            local pts = pipe.new * conn
                * pipe.map(function(c) return info.arcs.center.inf * (1 - c) + info.arcs.center.sup * c end)
                * pipe.map(function(rad) return info.arcs.center:pt(rad) + coor.xyz(0, 0, info.height) end)
            
            insert(result.models, ust.unitLane(pts[1], pts[2], tag, "ust/transport_lane.mdl"))
        end
    end
    
    -- params.edgeIndex[slotId] = #result.edgeLists
    -- if (info.octa[1] and params.modules[info.octa[1]].metadata.isStreet) then
    --     insert(result.invokeLater, function()
    --         local indexL = params.edgeIndex[slotId]
    --         local indexR = params.edgeIndex[info.octa[1]]
    --         local edgesL = result.edgeLists[indexL]
    --         local edgesR = result.edgeLists[indexR]
    --         local nodeL = edgesL.edges[edgesL.seqNodes[#edgesL.seqNodes] + 1]
    --         local nodeR = edgesR.edges[edgesR.seqNodes[1] + 1]
    --         local ptL = coor.tuple2Vec(nodeL[1])
    --         local ptR = coor.tuple2Vec(nodeR[1])
    --         local pt = ptL:avg(ptR):toTuple()
    --         result.edgeLists[indexL].edges[edgesL.seqNodes[#edgesL.seqNodes] + 1][0] = pt
    --         result.edgeLists[indexR].edges[edgesR.seqNodes[1] + 1][1] = pt
    --     end)
    -- end



    local n = 4
    
    local leftPts = ust.basePts(info.arcs.left, n)
    local rightPts = ust.basePts(info.arcs.right, n)

    
    for i = 1, n do
        local sup = i + 1
        local inf = i
        local centre = {
            lt = leftPts[sup],
            rt = rightPts[sup],
            lb = leftPts[inf],
            rb = rightPts[inf],
        }
        
        insert(result.models, ust.newModel("ust/paving/brick_tl.mdl", tag, coor.transZ(info.height) * fitModels(centre, true)));
        insert(result.models, ust.newModel("ust/paving/brick_br.mdl", tag, coor.transZ(info.height) * fitModels(centre, false)));
    end

    local face = pipe.new + leftPts + func.rev(rightPts)
    
    ust.initTerrainList(result, info.id)
    
    result.groundFaceLists[info.id] = {
        face = func.map(face, coor.vec2Tuple),
        modes = {
            {
                type = "FILL",
                key = "shared/asphalt_01.gtex.lua"
            },
            {
                type = "STROKE_OUTER",
                key = "street_border.lua"
            },
        },
    }


    if params.debug == 1 then
        local text = tostring(info.id)
        local pos = string.format("(%d, %d)", info.pos.x, info.pos.y)
        
        local addText = function(label, pos, fAlign, h)
            local nameModelsF, width = livetext(h or 2)(label)
            for _, m in ipairs(nameModelsF(function() return coor.trans(fAlign(width)) * coor.rotX90N * quat.byVec(coor.xyz(0, 1, 0), info.gravity[2]):mRot() * coor.trans(pos) * coor.transZ(info.height + 0.5) end)) do
                insert(result.models, m)
            end
        end
        
        addText(text, info.gravity[1], function(w) return coor.xyz(-0.5 * w, 0, 0) end)
        addText(pos, info.gravity[1], function(w) return coor.xyz(-0.5 * w, 0, -2) end, 0.75)
        
        ust.marking(result, slotId, params)
    end
end

function data()
    return {
        availability = {
            yearFrom = 0,
            yearTo = 0,
        },
        buildMode = "SINGLE",
        cost = {
            price = 0,
        },
        description = {
            name = _("MENU_MODULE_CATENARY"),
            description = _("MENU_MODULE_CATENARY_DESC"),
        },
        category = {
            categories = {"ust_cat_street"},
        },
        type = "ust_street",
        order = {
            value = 1,
        },
        metadata = {
            typeName = "ust_street",
            isStreet = true,
            width = 5,
            height = 0,
            typeId = 4,
            scriptName = "construction/station/rail/ust/struct/street",
            preProcessAdd = "preProcessAdd",
            preProcessRemove = "preProcessRemove",
            slotSetup = "slotSetup",
            preClassify = "preClassify",
            postClassify = "postClassify",
            gridization = "gridization"
        },
        updateFn = updateFn,
        
        getModelsFn = function(params)
            return {}
        end
    }
end
