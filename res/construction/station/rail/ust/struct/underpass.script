local ust = require "ust"
local coor = require "ust/coor"
local quat = require "ust/quaternion"

local insert = table.insert

local addSlot = function(params, result)
    for id, info in pairs(params.classedModules) do
        local module = params.modules[info.slotId]
        if (module.metadata and module.metadata.isPlatform) then
            local info = module.info
            local makeData = module.makeData
            
            local centerPts, centerVecs = ust.basePts(info.arcs.center, 4)
            
            local centerPt0 = centerPts[3]:avg(centerPts[2])
            local centerVec0 = centerVecs[3]:avg(centerVecs[2])
            local centerPt1 = centerPts[3]:avg(centerPts[4])
            local centerVec1 = centerVecs[3]:avg(centerVecs[4])
            
            local centerTransf0 = (quat.byVec(coor.xyz(1, 0, 0), centerVec0):mRot()) * coor.trans(centerPt0)
            local centerTransf1 = (quat.byVec(coor.xyz(-1, 0, 0), centerVec1):mRot()) * coor.trans(centerPt1)
            
            table.insert(result.slots, {
                id = makeData(21, 0),
                transf = centerTransf0,
                type = "ust_underpass",
                shape = 1,
                spacing = {0, 0, 0, 0}
            })
            
            table.insert(result.slots, {
                id = makeData(21, 1),
                transf = centerTransf1,
                type = "ust_underpass",
                shape = 1,
                spacing = {0, 0, 0, 0}
            })
        end
    end
end

local invokeLater2 = function(result, tag, slotId, fitModel)
    local current = result.connectors.underpass[slotId]
    local leftConnector = current.connectors.left
    local rightConnector = current.connectors.right
    local targets = current.targets
    
    if targets.left then
        local mTarget = result.connectors.underpass[targets.left.slotId]
        if mTarget.targets.right and mTarget.targets.right.slotId == slotId then
            insert(result.models, ust.unitLane(leftConnector, targets.left.from:avg(targets.left.to), tag))
            
            local targetBottomPts = mTarget.bottomPts
            
            local pts = {
                lt = current.bottomPts.lt:avg(targetBottomPts.rt),
                lb = current.bottomPts.lb:avg(targetBottomPts.rb),
                rb = current.bottomPts.lb,
                rt = current.bottomPts.lt
            }
            
            insert(result.models, ust.newModel("ust/platform/era_c/underpass_tunnel_tl.mdl", tag, fitModel(pts, true)));
            insert(result.models, ust.newModel("ust/platform/era_c/underpass_tunnel_br.mdl", tag, fitModel(pts, false)));
            
            if current.fnOpen and current.fnOpen.left then
                insert(result.invokeLater, current.fnOpen.left)
            end
        elseif current.fnClosed and current.fnClosed.left then
            insert(result.invokeLater, current.fnClosed.left)
        end
    elseif current.fnClosed and current.fnClosed.left then
        insert(result.invokeLater, current.fnClosed.left)
    end
    
    
    if targets.right then
        local mTarget = result.connectors.underpass[targets.right.slotId]
        if mTarget.targets and mTarget.targets.left.slotId == slotId then
            insert(result.models, ust.unitLane(rightConnector, targets.right.from:avg(targets.right.to), tag))
            
            local targetBottomPts = mTarget.bottomPts
            
            local pts = {
                rt = current.bottomPts.rt:avg(targetBottomPts.lt),
                rb = current.bottomPts.rb:avg(targetBottomPts.lb),
                lb = current.bottomPts.rb,
                lt = current.bottomPts.rt
            }
            
            insert(result.models, ust.newModel("ust/platform/era_c/underpass_tunnel_tl.mdl", tag, fitModel(pts, true)));
            insert(result.models, ust.newModel("ust/platform/era_c/underpass_tunnel_br.mdl", tag, fitModel(pts, false)));
            
            if current.fnOpen and current.fnOpen.right then
                insert(result.invokeLater, current.fnOpen.right)
            end
        elseif current.fnClosed and current.fnClosed.right then
            insert(result.invokeLater, current.fnClosed.right)
        end
    elseif current.fnClosed and current.fnClosed.right then
        insert(result.invokeLater, current.fnClosed.right)
    end
end

local invokeLater = function(result, tag, slotId, fitModel)
    local current = result.connectors.underpass[slotId]
    return function()
        local leftConnector = current.connectors.left
        local rightConnector = current.connectors.right
        
        local targets = {
            left = nil,
            right = nil,
        }
        
        for slotIdTarget, target in pairs(result.connectors.underpass) do
            if slotId ~= slotIdTarget and (not target.front or target.front.slotId ~= slotIdTarget) then
                if ((current.pos.x - target.pos.x == 1 and current.pos.y == target.pos.y) or (current.pos.x - target.pos.x > 1)) and leftConnector and target.connectors.right then
                    local vec = leftConnector - target.connectors.right
                    if math.abs(vec:normalized():dot(current.vec)) < 0.72 then
                        if not targets.left
                            or (targets.left and current.pos.y ~= targets.left.y and target.pos.y == current.pos.y)
                            or (targets.left and targets.left.y == current.pos.y and target.pos.y == current.pos.y and vec:length2() < targets.left.distance)
                            or (targets.left and targets.left.y ~= current.pos.y and vec:length2() < targets.left.distance)
                        then
                            targets.left = {
                                distance = vec:length2(),
                                y = target.pos.y,
                                from = leftConnector,
                                to = target.connectors.right,
                                slotId = slotIdTarget
                            }
                        end
                    end
                elseif ((target.pos.x - current.pos.x == 1 and current.pos.y == target.pos.y) or (target.pos.x - current.pos.x > 1)) and rightConnector and target.connectors.left then
                    local vec = rightConnector - target.connectors.left
                    if math.abs(vec:normalized():dot(current.vec)) < 0.72 then
                        if not targets.right
                            or (targets.right and current.pos.y ~= targets.right.y and target.pos.y == current.pos.y)
                            or (targets.right and targets.right.y == current.pos.y and target.pos.y == current.pos.y and vec:length2() < targets.right.distance)
                            or (targets.right and targets.right.y ~= current.pos.y and vec:length2() < targets.right.distance)
                        then
                            targets.right = {
                                distance = vec:length2(),
                                y = target.pos.y,
                                from = rightConnector,
                                to = target.connectors.left,
                                slotId = slotIdTarget
                            }
                        end
                    end
                end
            end
        end
        
        result.connectors.underpass[slotId].targets = targets
        
        insert(
            result.invokeLater,
            function()
                invokeLater2(result, tag, slotId, fitModel)
            end
    )
    end
end

function data()
    return {
        classify = ust.classifyComp,
        addSlot = addSlot,
        invokeLater = invokeLater
    }
end
