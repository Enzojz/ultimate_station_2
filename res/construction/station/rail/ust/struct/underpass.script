local ust = require "ust"
local coor = require "ust/coor"
local quat = require "ust/quaternion"
local dump = require "luadump"

local insert = table.insert
local unpack = table.unpack

local addSlot = function(params, result)
    for id, info in pairs(params.classedModules) do
        local module = params.modules[info.slotId]
        if (module.metadata and module.metadata.isPlatform) then
            local info = module.info
            local makeData = module.makeData
            
            local centerPts, centerVecs = ust.basePts(info.arcs.center, 2)
            
            local centerPt = centerPts[2]
            local centerVec = centerVecs[2]
            
            local centerTransf = (quat.byVec(coor.xyz(0, 1, 0), centerVec):mRot()) * coor.trans(centerPt)
            
            table.insert(result.slots, {
                id = makeData(21, 0),
                transf = centerTransf,
                type = "ust_underpass",
                spacing = {0, 0, 0, 0}
            })
        end
    end
end

local invokeLater2 = function(result, tag, slotId, fitModel, hasDeadend)
    local current = result.connectors.underpass[slotId]
    local leftConnector = current.connectors.left
    local rightConnector = current.connectors.right
    local targets = current.targets
    
    do
        if targets.left and result.connectors.underpass[targets.left.slotId].targets.right.slotId == slotId then
            insert(result.models, ust.unitLane(leftConnector, targets.left.from:avg(targets.left.to), tag))
            
            local targetBottomPts = result.connectors.underpass[targets.left.slotId].bottomPts
            
            local pts = {
                lt = current.bottomPts.lt:avg(targetBottomPts.rt),
                lb = current.bottomPts.lb:avg(targetBottomPts.rb),
                rb = current.bottomPts.lb,
                rt = current.bottomPts.lt
            }
            
            insert(result.models, ust.newModel("ust/platform/era_c/underpass_tunnel_tl.mdl", tag, fitModel(pts, true)));
            insert(result.models, ust.newModel("ust/platform/era_c/underpass_tunnel_br.mdl", tag, fitModel(pts, false)));
        elseif hasDeadend then
            local vec = current.bottomPts.lt - current.bottomPts.lb
            local pt = current.bottomPts.lt:avg(current.bottomPts.lb)
            insert(result.models, ust.newModel("ust/platform/era_c/underpass_deadend.mdl", tag, quat.byVec(coor.xyz(0, 1, 0), vec):mRot() * coor.trans(pt)));
        end
    end
    
    do
        if targets.right and result.connectors.underpass[targets.right.slotId].targets.left.slotId == slotId then
            insert(result.models, ust.unitLane(rightConnector, targets.right.from:avg(targets.right.to), tag))
            
            local targetBottomPts = result.connectors.underpass[targets.right.slotId].bottomPts
            
            local pts = {
                rt = current.bottomPts.rt:avg(targetBottomPts.lt),
                rb = current.bottomPts.rb:avg(targetBottomPts.lb),
                lb = current.bottomPts.rb,
                lt = current.bottomPts.rt
            }
            
            insert(result.models, ust.newModel("ust/platform/era_c/underpass_tunnel_tl.mdl", tag, fitModel(pts, true)));
            insert(result.models, ust.newModel("ust/platform/era_c/underpass_tunnel_br.mdl", tag, fitModel(pts, false)));
        elseif hasDeadend then
            local vec = current.bottomPts.rt - current.bottomPts.rb
            local pt = current.bottomPts.rt:avg(current.bottomPts.rb)
            insert(result.models, ust.newModel("ust/platform/era_c/underpass_deadend.mdl", tag, quat.byVec(coor.xyz(0, -1, 0), vec):mRot() * coor.trans(pt)));
        end
    end
end

local invokeLater = function(result, tag, slotId, fitModel, hasDeadend)
    local current = result.connectors.underpass[slotId]
    return function()
        local leftConnector = current.connectors.left
        local rightConnector = current.connectors.right
        
        local targets = {
            left = nil,
            right = nil
        }
        
        for slotIdTarget, target in pairs(result.connectors.underpass) do
            if slotId ~= slotIdTarget then
                if target.pos.x < current.pos.x and leftConnector then
                    local targetConnector = target.connectors.right
                    if targetConnector and ((current.pos.x - target.pos.x == 1 and current.pos.y == target.pos.y) or (current.pos.x - target.pos.x > 1)) then
                        local vec = leftConnector - targetConnector
                        if not targets.left
                            or (targets.left and current.pos.y ~= targets.left.distance and target.pos.y == current.pos.y)
                            or (targets.left and targets.left.distance == current.pos.y and target.pos.y == current.pos.y and vec:length2() < targets.left.distance)
                            or (targets.left and targets.left.distance ~= current.pos.y and vec:length2() < targets.left.distance)
                        then
                            targets.left = {
                                distance = vec:length2(),
                                y = target.pos.y,
                                from = leftConnector,
                                to = targetConnector,
                                slotId = slotIdTarget
                            }
                        end
                    end
                elseif target.pos.x > current.pos.x and rightConnector then
                    local targetConnector = target.connectors.left
                    if targetConnector and ((target.pos.x - current.pos.x == 1 and current.pos.y == target.pos.y) or (target.pos.x - current.pos.x > 1)) then
                        local vec = rightConnector - targetConnector
                        if not targets.right
                            or (targets.right and current.pos.y ~= targets.right.distance and target.pos.y == current.pos.y)
                            or (targets.right and targets.right.distance == current.pos.y and target.pos.y == current.pos.y and vec:length2() < targets.right.distance)
                            or (targets.right and targets.right.distance ~= current.pos.y and vec:length2() < targets.right.distance)
                        then
                            targets.right = {
                                distance = vec:length2(),
                                y = target.pos.y,
                                from = rightConnector,
                                to = targetConnector,
                                slotId = slotIdTarget
                            }
                        end
                    end
                end
            end
        end
        
        result.connectors.underpass[slotId].targets = targets
        
        insert(
            result.invokeLater,
            function()
                invokeLater2(result, tag, slotId, fitModel, hasDeadend)
            end
    )
    end
end

function data()
    return {
        classify = ust.classifyComp,
        addSlot = addSlot,
        invokeLater = invokeLater
    }
end
