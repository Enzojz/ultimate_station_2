local ust = require "ust"
local coor = require "ust/coor"
local quat = require "ust/quaternion"

local insert = table.insert
local unpack = table.unpack

local addSlot = function(params, result)
    for id, info in pairs(params.classedModules) do
        local module = params.modules[info.slotId]
        if (module.metadata and module.metadata.isPlatform) then
            local info = module.info
            local makeData = module.makeData
            
            local centerPts, centerVecs = ust.basePts(info.arcs.center, 2)
            
            local centerPt = centerPts[2]
            local centerVec = centerVecs[2]
            
            local centerTransf = (quat.byVec(coor.xyz(0, 1, 0), centerVec):mRot()) * coor.trans(centerPt)
            
            table.insert(result.slots, {
                id = makeData(21, 0),
                transf = centerTransf,
                type = "ust_underpass",
                spacing = {0, 0, 0, 0}
            })
        end
    end
end

local invokeLater = function(result, tag, slotId, fitModel, hasDeadend)
    local current = result.connectors.underpass[slotId]
    return function()
        local leftConnector = current.connectors.left
        local rightConnector = current.connectors.right
        
        local targets = {
            left = nil,
            right = nil
        }
        
        for slotIdTarget, target in pairs(result.connectors.underpass) do
            if slotId ~= slotIdTarget then
                if target.pos.x < current.pos.x and leftConnector then
                    local targetConnector = target.connectors.right
                    if targetConnector and ((current.pos.x - target.pos.x == 1 and current.pos.y == target.pos.y) or (current.pos.x - target.pos.x > 1)) then
                        local vec = leftConnector - targetConnector
                        if targets.left then
                            local distance = unpack(targets.left)
                            if (current.pos.y ~= distance.y and target.pos.y == current.pos.y) or
                                (distance.y == current.pos.y and target.pos.y == current.pos.y and vec:length2() < distance.x) or
                                (distance.y ~= current.pos.y and vec:length2() < distance.x)
                            then
                                targets.left = {coor.xy(vec:length2(), target.pos.y), leftConnector, targetConnector, slotIdTarget}
                            end
                        else
                            targets.left = {coor.xy(vec:length2(), target.pos.y), leftConnector, targetConnector, slotIdTarget}
                        end
                    end
                elseif target.pos.x > current.pos.x and rightConnector then
                    local targetConnector = target.connectors.left
                    if targetConnector and ((target.pos.x - current.pos.x == 1 and current.pos.y == target.pos.y) or (target.pos.x - current.pos.x > 1))  then
                        local vec = rightConnector - targetConnector
                        if targets.right then
                            local distance = unpack(targets.right)
                            if (current.pos.y ~= distance.y and target.pos.y == current.pos.y) or
                                (distance.y == current.pos.y and target.pos.y == current.pos.y and vec:length2() < distance.x) or
                                (distance.y ~= current.pos.y and vec:length2() < distance.x)
                            then
                                targets.right = {coor.xy(vec:length2(), target.pos.y), rightConnector, targetConnector, slotIdTarget}
                            end
                        else
                            targets.right = {coor.xy(vec:length2(), target.pos.y), rightConnector, targetConnector, slotIdTarget}
                        end
                    end
                end
            end
        end
        
        if targets.left then
            local _, from, to, slotIdTarget = unpack(targets.left)
            insert(result.models, ust.unitLane(leftConnector, from:avg(to), nil))
            
            local targetBottomPts = result.connectors.underpass[slotIdTarget].bottomPts
            
            local pts = {
                lt = current.bottomPts.lt:avg(targetBottomPts.rt),
                lb = current.bottomPts.lb:avg(targetBottomPts.rb),
                rb = current.bottomPts.lb,
                rt = current.bottomPts.lt
            }
            
            insert(result.models, ust.newModel("ust/platform/era_c/underpass_tunnel_tl.mdl", tag, fitModel(pts, true)));
            insert(result.models, ust.newModel("ust/platform/era_c/underpass_tunnel_br.mdl", tag, fitModel(pts, false)));
        elseif hasDeadend then
            local vec = current.bottomPts.lt - current.bottomPts.lb
            local pt = current.bottomPts.lt:avg(current.bottomPts.lb)
            insert(result.models, ust.newModel("ust/platform/era_c/underpass_deadend.mdl", tag, quat.byVec(coor.xyz(0, 1, 0), vec):mRot() * coor.trans(pt)));
        end
        
        if targets.right then
            local _, from, to, slotIdTarget = unpack(targets.right)
            insert(result.models, ust.unitLane(rightConnector, from:avg(to), nil))
            
            local targetBottomPts = result.connectors.underpass[slotIdTarget].bottomPts
            
            local pts = {
                rt = current.bottomPts.rt:avg(targetBottomPts.lt),
                rb = current.bottomPts.rb:avg(targetBottomPts.lb),
                lb = current.bottomPts.rb,
                lt = current.bottomPts.rt
            }
            
            insert(result.models, ust.newModel("ust/platform/era_c/underpass_tunnel_tl.mdl", tag, fitModel(pts, true)));
            insert(result.models, ust.newModel("ust/platform/era_c/underpass_tunnel_br.mdl", tag, fitModel(pts, false)));
        elseif hasDeadend then
            local vec = current.bottomPts.rt - current.bottomPts.rb
            local pt = current.bottomPts.rt:avg(current.bottomPts.rb)
            insert(result.models, ust.newModel("ust/platform/era_c/underpass_deadend.mdl", tag, quat.byVec(coor.xyz(0, -1, 0), vec):mRot() * coor.trans(pt)));
        end
    end
end

function data()
    return {
        classify = ust.classifyComp,
        addSlot = addSlot,
        invokeLater = invokeLater
    }
end
