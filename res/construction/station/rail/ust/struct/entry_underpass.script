local ust = require "ust"
local coor = require "ust/coor"
local func = require "ust/func"
local pipe = require "ust/pipe"
local quat = require "ust/quaternion"

local insert = table.insert

local fitModels = {
    middle = ust.fitModel(0.5, 1.45, 1, true, true),
    side = ust.fitModel(0.5, 1.775, 1, true, true),
    wall = ust.fitModel(0.5, 5, 1, true, true),
    underpass = ust.fitModel(1.9, 1.45, -1, true, true)
}

local addSlot = function(params, result)
    for id, info in pairs(params.classedModules) do
        local module = params.modules[info.slotId]
        if module.metadata and (module.metadata.isPlatform or module.metadata.isTrack or module.metadata.isStreet) then
            local info = module.info
            local makeData = module.makeData
            
            local octa7 = params.modules[info.octa[7]]
            local octa3 = params.modules[info.octa[3]]
            
            local n = 4
            
            local ptsL, vecL = ust.basePts(info.arcs.left, n)
            local ptsR, vecR = ust.basePts(info.arcs.right, n)
            
            if not octa7 or info.height - octa7.info.height >= 4.4 then
                for i = 1, 4 do
                    local refPtL = ptsL[i + 1]:avg(ptsL[i])
                    local refVecL = vecL[i + 1]:avg(vecL[i])
                    
                    local transfL =
                        quat.byVec(coor.xyz(1, 0, 0), refVecL):mRot()
                        * coor.trans(refPtL)
                    
                    insert(
                        result.slots, {
                            id = makeData(34, i * 10 + 7),
                            transf = coor.scale(coor.xyz(2.5, 0.25, 1)) * transfL,
                            type = "ust_component_underpass_entry",
                            spacing = {0, 0, 0, 0}
                        })
                end
            end
            
            if not octa3 or info.height - octa3.info.height >= 4.4 then
                for i = 1, 4 do
                    local refPtR = ptsR[i + 1]:avg(ptsR[i])
                    local refVecR = vecR[i + 1]:avg(vecR[i])
                    
                    local transfR =
                        quat.byVec(coor.xyz(1, 0, 0), refVecR):mRot()
                        * coor.trans(refPtR)
                    
                    insert(
                        result.slots, {
                            id = makeData(34, i * 10 + 3),
                            transf = coor.scale(coor.xyz(2.5, 0.25, 1)) * transfR,
                            type = "ust_component_underpass_entry",
                            spacing = {0, 0, 0, 0}
                        })
                end
            end
        end
    end
end

local slotSetup = function(params, result, slotId)
    local id = params.modules[slotId].info.id
    local m = params.modules[params.classedModules[id].slotId]
    local data = params.modules[slotId].info.data
    local octa = data % 10
    
    local info = m.info
    local hPlatform = info.height > 4.4 and info.height or 4.4
    
    local rightPlatform = m.info.octa[3] and (params.modules[m.info.octa[3]].metadata.isPlatform or params.modules[m.info.octa[3]].metadata.isPlaceholder)
    local leftPlatform = m.info.octa[7] and (params.modules[m.info.octa[7]].metadata.isPlatform or params.modules[m.info.octa[7]].metadata.isPlaceholder)
    if octa == 3 and rightPlatform then
        if params.modules[m.info.octa[3]].metadata.isPlatform then
            params.modules[slotId].info.rightPlatform = m.info.octa[3]
        end
        local mRight = params.modules[m.info.octa[3]]
        local hPlatformRight = mRight.info.height
        if hPlatform - hPlatformRight > 4.4 then
            hPlatform = hPlatform - hPlatformRight
        end
    elseif octa == 7 and leftPlatform then
        if params.modules[m.info.octa[7]].metadata.isPlatform then
            params.modules[slotId].info.leftPlatform = m.info.octa[7]
        end
        local mLeft = params.modules[m.info.octa[7]]
        local hPlatformLeft = mLeft.info.height
        if hPlatform - hPlatformLeft > 4.4 then
            hPlatform = hPlatform - hPlatformLeft
        end
    end
    
    params.modules[slotId].info.height = hPlatform
end

local preProcessRemove = function(modules, change, classedModules, info)
    local type, id = ust.slotInfo(change.slotId)
    modules[change.slotId] = nil
    
    if modules[ust.mixData(ust.base(id, 89), 3)] then
        modules[ust.mixData(ust.base(id, 89), 3)] = nil
    end
    if modules[ust.mixData(ust.base(id, 89), 7)] then
        modules[ust.mixData(ust.base(id, 89), 7)] = nil
    end
end


local updateFn = function(result, transform, tag, slotId, addModelFn, params, model)
    local id = params.modules[slotId].info.id
    local m = params.modules[params.classedModules[id].slotId]
    local data = params.modules[slotId].info.data
    
    local info = m.info
    local hPlatform = params.modules[slotId].info.height
    local hRef = -hPlatform
    
    local octa = data % 10
    if octa == 3 or octa == 7 then
        local n = 4
        local cpts = ust.basePts(info.arcs.center, n)
        local pts = ust.basePts(octa == 3 and info.arcs.right or info.arcs.left, n)
        
        local i = (data - octa) / 10
        
        local fnClosed = function()
            local coords = octa == 7 and {
                lt = pts[i],
                lb = pts[i + 1],
                rt = (pts[i] - cpts[i]):normalized() * 0.25 + pts[i],
                rb = (pts[i + 1] - cpts[i + 1]):normalized() * 0.25 + pts[i + 1]
            } or {
                rt = pts[i],
                rb = pts[i + 1],
                lt = (pts[i] - cpts[i]):normalized() * 0.25 + pts[i],
                lb = (pts[i + 1] - cpts[i + 1]):normalized() * 0.25 + pts[i + 1]
            }
            insert(result.models, ust.newModel("ust/walls/" .. model .. "_tl.mdl", tag, coor.scaleZ(hPlatform) * coor.transZ(hRef) * fitModels.wall(coords, true)))
            insert(result.models, ust.newModel("ust/walls/" .. model .. "_br.mdl", tag, coor.scaleZ(hPlatform) * coor.transZ(hRef) * fitModels.wall(coords, false)))
        end
        
        local ptsBaseLength = (pts[i + 1] - pts[i]):length()
        local ptsVec = (pts[i + 1] - pts[i]):normalized() * (ptsBaseLength - 1.45);
        local pts = {pts[i], pts[i] + ptsVec * 0.5, pts[i + 1] - ptsVec * 0.5, pts[i + 1]}
        
        local cptsBaseLength = (cpts[i + 1] - cpts[i]):length()
        local cptsVec = (cpts[i + 1] - cpts[i]):normalized() * (cptsBaseLength - 1.45);
        local cpts = {cpts[i], cpts[i] + cptsVec * 0.5, cpts[i + 1] - cptsVec * 0.5, cpts[i + 1]}
        
        
        local fnOpen = function()
            local coords = func.map2(
                func.interlace(pts),
                func.interlace(cpts),
                function(pts, cpts)
                    return octa == 7 and {
                        lt = pts[1],
                        lb = pts[2],
                        rt = (pts[1] - cpts[1]):normalized() * 0.25 + pts[1],
                        rb = (pts[2] - cpts[2]):normalized() * 0.25 + pts[2]
                    } or {
                        rt = pts[1],
                        rb = pts[2],
                        lt = (pts[1] - cpts[1]):normalized() * 0.25 + pts[1],
                        lb = (pts[2] - cpts[2]):normalized() * 0.25 + pts[2]
                    }
                end)
            
            insert(result.models, ust.newModel("ust/underpass_entry/" .. model .. "_l_tl.mdl", tag, coor.scaleZ(hPlatform) * coor.transZ(hRef) * fitModels.side(coords[1], true)))
            insert(result.models, ust.newModel("ust/underpass_entry/" .. model .. "_l_br.mdl", tag, coor.scaleZ(hPlatform) * coor.transZ(hRef) * fitModels.side(coords[1], false)))
            insert(result.models, ust.newModel("ust/underpass_entry/" .. model .. "_r_tl.mdl", tag, coor.scaleZ(hPlatform) * coor.transZ(hRef) * fitModels.side(coords[3], true)))
            insert(result.models, ust.newModel("ust/underpass_entry/" .. model .. "_r_br.mdl", tag, coor.scaleZ(hPlatform) * coor.transZ(hRef) * fitModels.side(coords[3], false)))
            insert(result.models, ust.newModel("ust/underpass_entry/" .. model .. "_m_tl.mdl", tag, coor.scaleZ(hPlatform - 2.2) * coor.transZ(hRef + 2.2) * fitModels.middle(coords[2], true)))
            insert(result.models, ust.newModel("ust/underpass_entry/" .. model .. "_m_br.mdl", tag, coor.scaleZ(hPlatform - 2.2) * coor.transZ(hRef + 2.2) * fitModels.middle(coords[2], false)))
            
            insert(result.models, ust.newModel("station/rail/asset/era_c_station_name.mdl", tag,
                coor.rotZ90N * coor.trans(coor.xyz(octa == 7 and 0.03 or -0.03, 0, hRef + 2.2)) * quat.byVec(coor.xyz(0, 1, 0), (pts[2] - pts[3]):normalized()):mRot() * coor.trans(pts[2]:avg(pts[3]))));
        end
        
        result.connectors.underpass[slotId] = octa == 7 and {
            pos = info.pos + coor.xyz(info.pos.x * 2 - 1, 0, 0),
            bottomPts = {
                rt = pts[3] .. coor.transZ(hRef),
                rb = pts[2] .. coor.transZ(hRef),
                lt = cpts[3] .. coor.transZ(hRef),
                lb = cpts[2] .. coor.transZ(hRef),
            },
            connectors = {
                right = pts[2]:avg(pts[3]) .. coor.transZ(hRef)
            },
            height = hPlatform,
            vec = ptsVec:normalized(),
            fnOpen = {right = fnOpen},
            fnClosed = {right = fnClosed}
        } or {
            pos = info.pos + coor.xyz(info.pos.x * 2 + 1, 0, 0),
            bottomPts = {
                lt = pts[3] .. coor.transZ(hRef),
                lb = pts[2] .. coor.transZ(hRef),
                rt = cpts[3] .. coor.transZ(hRef),
                rb = cpts[2] .. coor.transZ(hRef),
            },
            connectors = {
                left = pts[2]:avg(pts[3]) .. coor.transZ(hRef),
            },
            height = hPlatform,
            vec = ptsVec:normalized(),
            fnOpen = {left = fnOpen},
            fnClosed = {left = fnClosed}
        }
        
        insert(
            result.invokeLater,
            game.res.script["construction/station/rail/ust/struct/underpass"].invokeLater(result, tag, slotId, fitModels.underpass)
        )
        function platformConnection(lane, connector)
            if lane then
                local connections = pipe.new * lane
                    * pipe.map(function(pt) return {pt = pt, distance = (pt - connector):length2()} end)
                    * pipe.sort(function(lhs, rhs) return lhs.distance < rhs.distance end)
                
                if #connections > 0 then
                    insert(result.models, ust.unitLane(connections[1].pt, connector, tag))
                end
                
                if #connections > 1 then
                    insert(result.models, ust.unitLane(connections[2].pt, connector, tag))
                end
            end
        end
        
        function extConnection(connector)
            for _, pt in ipairs({pts[2], pts[3]}) do
                insert(result.models, ust.unitLane(connector, (pt .. coor.transZ(hRef)):avg(connector), tag, "ust/linking_lane.mdl"))
            end
        end
        
        if octa == 7 then
            if params.modules[slotId].info.leftPlatform then
                platformConnection(
                    params.extra[params.modules[slotId].info.leftPlatform].rightLane,
                    result.connectors.underpass[slotId].connectors.right
            )
            else
                extConnection(result.connectors.underpass[slotId].connectors.right)
            end
        end
        
        if octa == 3 then
            if params.modules[slotId].info.rightPlatform then
                platformConnection(
                    params.extra[params.modules[slotId].info.rightPlatform].leftLane,
                    result.connectors.underpass[slotId].connectors.left
            )
            else
                extConnection(result.connectors.underpass[slotId].connectors.left)
            end
        end
    
    end
end


function data()
    return {
        classify = ust.classifyComp,
        addSlot = addSlot,
        slotSetup = slotSetup,
        preProcessRemove = preProcessRemove,
        updateFn = updateFn
    }
end
