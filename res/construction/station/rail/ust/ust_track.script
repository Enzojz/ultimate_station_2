local func = require "ust/func"
local coor = require "ust/coor"
local pipe = require "ust/pipe"
local ust = require "ust"
local general = require "ust/general"
local quat = require "ust/quaternion"
local dump = require "luadump"
local livetext = require "ust/livetext"


local unpack = table.unpack
local insert = table.insert
local ma = math
local pi = ma.pi
local abs = ma.abs
local pow = ma.pow

local updateFn = function(result, transform, tag, slotId, addModelFn, params, closureParams)
    local trackType = closureParams.trackType
    local catenary = closureParams.catenary
    
    local info = params.modules[slotId].info
    local makeData = params.modules[slotId].makeData
    
    local pts = info.pts
    
    local e = {{}, {}}
    
    if (info.pos.y > 0) then
        e = {
            info.octa[5] and params.modules[info.octa[5]].metadata.isTrack and {
                pts[1][1]:avg(params.modules[info.octa[5]].info.pts[2][1]),
                pts[1][2]:avg(params.modules[info.octa[5]].info.pts[2][2])
            } or pts[1],
            
            info.octa[1] and params.modules[info.octa[1]].metadata.isTrack and {
                pts[2][1]:avg(params.modules[info.octa[1]].info.pts[1][1]),
                pts[2][2]:avg(params.modules[info.octa[1]].info.pts[1][2])
            } or pts[2]
        }
    elseif (info.pos.y == 0) then
        e = {
            info.octa[5] and params.modules[info.octa[5]].metadata.isTrack and {
                pts[1][1]:avg(params.modules[info.octa[5]].info.pts[1][1]),
                pts[1][2]:avg(-params.modules[info.octa[5]].info.pts[1][2])
            } or pts[1],
            
            info.octa[1] and params.modules[info.octa[1]].metadata.isTrack and {
                pts[2][1]:avg(params.modules[info.octa[1]].info.pts[1][1]),
                pts[2][2]:avg(params.modules[info.octa[1]].info.pts[1][2])
            } or pts[2]
        }
    elseif (info.pos.y == -1) then
        e = {
            info.octa[1] and params.modules[info.octa[1]].metadata.isTrack and {
                pts[1][1]:avg(params.modules[info.octa[1]].info.pts[1][1]),
                pts[1][2]:avg(-params.modules[info.octa[1]].info.pts[1][2])
            } or pts[1],
            
            info.octa[5] and params.modules[info.octa[5]].metadata.isTrack and {
                pts[2][1]:avg(params.modules[info.octa[5]].info.pts[1][1]),
                pts[2][2]:avg(params.modules[info.octa[5]].info.pts[1][2])
            } or pts[2],
        
        }
    else
        e = {
            info.octa[1] and params.modules[info.octa[1]].metadata.isTrack and {
                pts[1][1]:avg(params.modules[info.octa[1]].info.pts[2][1]),
                pts[1][2]:avg(params.modules[info.octa[1]].info.pts[2][2])
            } or pts[1],
            
            info.octa[5] and params.modules[info.octa[5]].metadata.isTrack and {
                pts[2][1]:avg(params.modules[info.octa[5]].info.pts[1][1]),
                pts[2][2]:avg(params.modules[info.octa[5]].info.pts[1][2])
            } or pts[2],
        
        }
    end
    
    table.insert(result.models, func.with(ust.unitLane(coor.xyz(0, 0, -2) + pts[2][1], coor.xyz(0, 0, -2) + pts[1][1]), {tag = tag}))
    
    local e = pipe.new * e * pipe.map(function(e) return {e[1], e[2] * info.length} end) * pipe.map(pipe.map(coor.vec2Tuple))
    
    local edges = {
        type = "TRACK",
        alignTerrain = true,
        params = {
            type = trackType,
            catenary = catenary,
        },
        edges = e,
        snapNodes = {},
        freeNodes = {},
        tag2nodes = {
            [tag] = func.seq(0, #e - 1)
        },
        slot = slotId
    }
    
    table.insert(result.edgeLists, edges)
    
    
    local arcs = info.arcs
    local rad = (arcs.center.inf + arcs.center.sup) * 0.5
    local posL, posR = arcs.left:pt(rad), arcs.right:pt(rad)
    local vec = (posR - posL):normalized()
    local posC = (posR + posL) * 0.5
    local rotZ = quat.byVec(coor.xyz(1, 0, 0), vec):mRot()
    local transfPosC = rotZ * coor.trans(posC)
    
    if not params.anyRadiusModifiable then
        table.insert(result.slots, {
            id = makeData(80, 0),
            transf = transfPosC * coor.transZ(1),
            type = "ust_modifier",
            spacing = {0, 0, 0, 0}
        })
    end
    
    if (info.id ~= 1) then
        insert(result.slots, {
            id = makeData(99, 0),
            transf = transfPosC * coor.transZ(1),
            type = "ust_remove",
            spacing = {0, 0, 0, 0}
        })
    end
    
    local pos = info.pos
    local metadata = params.modules[slotId].metadata
    local refArc = arcs.center
    
    if not params.slotGrid[pos.z] then params.slotGrid[pos.z] = {} end
    if not params.slotGrid[pos.z][pos.x] then params.slotGrid[pos.z][pos.x] = {} end
    if not params.slotGrid[pos.z][pos.x][pos.y] then params.slotGrid[pos.z][pos.x][pos.y] = {} end
    if not params.slotGrid[pos.z][pos.x - 1] then params.slotGrid[pos.z][pos.x - 1] = {} end
    if not params.slotGrid[pos.z][pos.x + 1] then params.slotGrid[pos.z][pos.x + 1] = {} end
    if not params.slotGrid[pos.z][pos.x - 1][pos.y] then params.slotGrid[pos.z][pos.x - 1][pos.y] = {} end
    if not params.slotGrid[pos.z][pos.x + 1][pos.y] then params.slotGrid[pos.z][pos.x + 1][pos.y] = {} end
    if not params.slotGrid[pos.z][pos.x][pos.y - 1] then params.slotGrid[pos.z][pos.x][pos.y - 1] = {} end
    if not params.slotGrid[pos.z][pos.x][pos.y + 1] then params.slotGrid[pos.z][pos.x][pos.y + 1] = {} end
    
    table.insert(
        result.slots,
        {
            id = makeData(1, 9),
            transf = transfPosC * coor.transZ(1),
            type = "ust_track",
            spacing = {1.5, 1.5, 1.5, 1.5}
        }
    )
    if not (info.octa[3]) then
        local transf = coor.trans(coor.xyz(metadata.width, 0, 0)) * transfPosC
        
        params.slotGrid[pos.z][pos.x + 1][pos.y].track = {
            id = makeData(1, 3),
            transf = transf,
            type = "ust_track",
            spacing = {1.5, 1.5, 1.5, 1.5}
        }
        params.slotGrid[pos.z][pos.x + 1][pos.y].platform = {
            id = makeData(2, 3),
            transf = transf,
            type = "ust_platform",
            spacing = {1.5, 1.5, 1.5, 1.5}
        }
    end
    
    if not (info.octa[7]) then
        local transf = coor.trans(coor.xyz(-metadata.width, 0, 0)) * transfPosC
        params.slotGrid[pos.z][pos.x - 1][pos.y].track = {
            id = makeData(1, 7),
            transf = transf,
            type = "ust_track",
            spacing = {1.5, 1.5, 1.5, 1.5}
        }
        params.slotGrid[pos.z][pos.x - 1][pos.y].platform = {
            id = makeData(2, 7),
            transf = transf,
            type = "ust_platform",
            spacing = {1.5, 1.5, 1.5, 1.5}
        }
    end
    
    if not ((pos.y < 0 and info.octa[5]) or (pos.y > 0 and info.octa[1])) then
        local fwPt = refArc.sup + 0.5 * (refArc.sup - refArc.inf)
        local transf = quat.byVec(coor.xyz(0, 1, 0), refArc:tangent(fwPt)):mRot() * coor.trans(refArc:pt(fwPt))
        
        params.slotGrid[pos.z][pos.x][pos.y + 1].track = {
            id = makeData(1, 1),
            transf = transf,
            type = "ust_track",
            spacing = {1.5, 1.5, 1.5, 1.5}
        }
        params.slotGrid[pos.z][pos.x][pos.y + 1].platform = {
            id = makeData(2, 1),
            transf = transf,
            type = "ust_platform",
            spacing = {1.5, 1.5, 1.5, 1.5}
        }
    end
    
    if not ((pos.y < 0 and info.octa[1]) or (pos.y > 0 and info.octa[5])) then
        local bwPt = refArc.inf - 0.5 * (refArc.sup - refArc.inf)
        local transf = quat.byVec(coor.xyz(0, -1, 0), refArc:tangent(bwPt)):mRot() * coor.trans(refArc:pt(bwPt))
        
        params.slotGrid[pos.z][pos.x][pos.y - 1].track = {
            id = makeData(1, 5),
            transf = transf,
            type = "ust_track",
            spacing = {1.5, 1.5, 1.5, 1.5}
        }
        params.slotGrid[pos.z][pos.x][pos.y - 1].platform = {
            id = makeData(2, 5),
            transf = transf,
            type = "ust_platform",
            spacing = {1.5, 1.5, 1.5, 1.5}
        }
    end
end
function data()
    return {
        updateFn = updateFn,
        getModelsFn = function(params)
            return {}
        end
    }

end
